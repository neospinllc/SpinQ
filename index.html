<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Count and Skein Strength Test</title>

  <!-- Only Chart.js required -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
  <!-- Excel export library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- PDF export library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    /* Reset for Squarespace embedding */
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: transparent;
    }

    html,
    body {
      height: auto;
      min-height: auto;
    }

    /* Container optimized for Squarespace embedding */
    .container {
      max-width: 1950px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.08);
    }

    /* Ensure container doesn't create unwanted spacing when embedded */
    @media (max-width: 768px) {
      .container {
        padding: 15px;
        border-radius: 12px;
      }
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 0;
      border-bottom: 2px solid #e0e0e0;
      margin-bottom: 20px;
      gap: 20px;
    }

    .app-title {
      font-size: 28px;
      font-weight: 700;
      color: #2c3e50;
      text-align: center;
      flex: 1;
    }

    .current-date {
      font-size: 16px;
      color: #7f8c8d;
      text-align: right;
      min-width: 180px;
    }

    .top-inputs {
      display: flex;
      justify-content: space-between;
      gap: 30px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .column {
      flex: 1;
      min-width: 360px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .input-card {
      border-radius: 16px;
      padding: 18px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .input-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
    }

    .card-title {
      font-size: 16px;
      font-weight: 650;
      color: #2c3e50;
      margin-bottom: 8px;
    }

    .card-subtitle {
      font-size: 12px;
      color: #7f8c8d;
      margin-top: -4px;
      margin-bottom: 8px;
    }

    .card-input {
      width: 100%;
      padding: 12px 14px;
      font-size: 16px;
      border: none;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.75);
      box-sizing: border-box;
    }

    .card-input:focus {
      outline: none;
      background: white;
    }

    .card-report {
      background: #e3f2fd;
    }

    .card-report .card-input {
      background: #d1e7fd;
    }

    .card-testdate {
      background: #fff0f5;
    }

    .card-testdate .card-input {
      background: #ffe0eb;
    }

    .card-operator {
      background: #f0f4f8;
    }

    .card-operator .card-input {
      background: #e2e8f0;
    }

    .header-inputs-row {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 16px;
      margin-bottom: 16px;
    }

    .products-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 16px;
      margin-top: 0;
    }

    .product-block {
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .product-block:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.12);
    }

    .product-qtip {
      background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    }

    .product-triple {
      background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%);
    }

    .product-organic {
      background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
    }

    .product-special {
      background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
    }

    .product-custom {
      background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%);
    }

    .product-header {
      margin-bottom: 12px;
    }

    .product-name {
      font-size: 16px;
      font-weight: 700;
      color: #1a237e;
    }

    .product-triple .product-name {
      color: #4a148c;
    }

    .product-organic .product-name {
      color: #1b5e20;
    }

    .product-special .product-name {
      color: #e65100;
    }

    .product-custom .product-name {
      color: #880e4f;
    }

    .product-inputs {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .product-input-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .product-input-group label {
      font-size: 13px;
      color: #37474f;
      font-weight: 600;
    }

    .product-input-group .card-input {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(0, 0, 0, 0.1);
    }

    .product-input-group .card-input:focus {
      background: white;
      border-color: rgba(0, 0, 0, 0.2);
    }

    /* Product row colors in data entry table */
    .row-qtip {
      background-color: #e3f2fd !important;
    }

    .row-triple {
      background-color: #f3e5f5 !important;
    }

    .row-organic {
      background-color: #e8f5e9 !important;
    }

    .row-special {
      background-color: #fff3e0 !important;
    }

    .row-custom {
      background-color: #fce4ec !important;
    }

    button {
      padding: 12px 22px;
      font-size: 16px;
      margin: 10px;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      transition: all 0.25s;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.18);
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
      transform: none !important;
    }

    button:disabled:hover {
      transform: none !important;
      box-shadow: none !important;
    }

    .btn-start {
      background: #3498db;
      color: white;
    }

    .btn-simulate {
      background: #9b59b6;
      color: white;
    }

    .btn-save {
      background: #4CAF50;
      color: white;
    }

    .btn-save:disabled {
      background: #9e9e9e;
      color: #f5f5f5;
    }

    .btn-print {
      background: #27ae60;
      color: white;
    }

    .btn-print:disabled {
      background: #9e9e9e;
      color: #f5f5f5;
    }

    .btn-danger {
      background: #e74c3c;
      color: white;
    }

    .btn-muted {
      background: #64748b;
      color: white;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      font-size: 14px;
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 10px;
      text-align: center;
      vertical-align: middle;
    }

    thead th {
      background: #f3f4f6;
      font-weight: 700;
    }

    td.avg-cell {
      font-weight: 700;
      background: #f8fafc;
    }

    tr.out-of-control td.avg-cell {
      background: #ffe5e5;
    }

    tr.out-of-control {
      outline: 2px solid #e74c3c;
      outline-offset: -2px;
    }

    .metrics {
      display: flex;
      gap: 12px;
      flex-wrap: nowrap;
      /* Force single row */
      justify-content: center;
      margin: 18px 0 6px;
      overflow-x: auto;
      /* Allow horizontal scroll if needed on very small screens */
    }

    .metric {
      background: #3498db;
      color: white;
      padding: 14px 12px;
      border-radius: 12px;
      flex: 1 1 0;
      /* Equal flex-basis for all boxes */
      min-width: 140px;
      /* Minimum width to prevent too much shrinking */
      max-width: 220px;
      /* Maximum width to prevent too much stretching */
      text-align: center;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.14);
      transition: background 0.3s;
    }

    .metric.out-of-control {
      background: #e74c3c;
    }

    .metric .label {
      font-size: 12px;
      opacity: 0.9;
      line-height: 1.3;
    }

    .metric .value {
      font-size: 20px;
      font-weight: 800;
      margin-top: 4px;
    }

    /* Adjust font sizes for smaller screens */
    @media (max-width: 1400px) {
      .metric .label {
        font-size: 11px;
      }

      .metric .value {
        font-size: 18px;
      }

      .metric {
        padding: 12px 10px;
        min-width: 120px;
      }
    }

    @media (max-width: 1100px) {
      .metric .label {
        font-size: 10px;
      }

      .metric .value {
        font-size: 16px;
      }

      .metric {
        padding: 10px 8px;
        min-width: 100px;
      }
    }

    .charts-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 18px;
      align-items: start;
    }

    @media (max-width: 1200px) {
      .charts-grid {
        grid-template-columns: 1fr;
      }
    }

    .details-panel {
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      margin: 10px 0;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
    }

    /* Inline details styling */
    .detail-row td {
      padding: 0 !important;
      background-color: #f8fafc !important;
    }

    .inline-details-container {
      padding: 20px;
      border-top: 2px solid #3498db;
      background: #fff;
    }

    /* Batch Metrics in Combined View */
    .batch-metric-box {
      padding: 15px !important;
      border-radius: 8px !important;
      color: #ffffff !important;
      text-align: center !important;
      border: none !important;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }

    .batch-metric-box .label {
      font-size: 12px !important;
      opacity: 0.9 !important;
      margin-bottom: 5px !important;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .batch-metric-box .value {
      font-size: 24px !important;
      font-weight: 700 !important;
    }

    .chart-card {
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
      min-height: 350px;
    }

    /* Table Styles */
    #sliverTable th:first-child,
    #sliverTable td:first-child {
      width: 60px;
    }

    #sliverTable th:last-child,
    #sliverTable td:last-child {
      width: 100px;
    }

    #sliverTable th:not(:first-child):not(:last-child),
    #sliverTable td:not(:first-child):not(:last-child) {
      width: auto;
    }

    #sliverTable {
      table-layout: fixed;
      width: 100%;
    }

    .chart-card h3 {
      margin: 0 0 10px;
      font-size: 16px;
      color: #2c3e50;
    }

    canvas {
      width: 100% !important;
      height: 360px !important;
    }

    .saved-tests {
      margin-top: 32px;
    }

    .saved-tests h2 {
      margin-top: 0;
    }

    .action-row {
      margin: 12px 0;
      text-align: center;
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .filter-section {
      background: #f8fafc;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }

    .filter-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .filter-tab {
      padding: 8px 16px;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }

    .filter-tab:hover {
      background: #f3f4f6;
    }

    .filter-tab.active {
      background: #3498db;
      color: white;
      border-color: #3498db;
    }

    .filter-content {
      display: none;
    }

    .filter-content.active {
      display: block;
    }

    .filter-row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .filter-label {
      font-weight: 600;
      color: #374151;
      min-width: 100px;
    }

    .filter-input {
      padding: 8px 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 14px;
    }

    .filter-buttons {
      display: flex;
      gap: 8px;
      margin-top: 12px;
    }

    .card-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-height: 150px;
      overflow-y: auto;
      padding: 8px;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 6px;
    }

    .card-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .details-panel {
      margin-top: 18px;
      border: 1px solid #e5e7eb;
      background: #f8fafc;
      border-radius: 16px;
      padding: 16px;
      display: none;
    }

    .details-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .details-title {
      font-weight: 800;
      color: #0f172a;
    }

    .details-meta {
      color: #334155;
      font-size: 14px;
      line-height: 1.5;
    }

    .details-table-wrap {
      margin-top: 10px;
      background: #fff;
      border-radius: 12px;
      padding: 10px;
      border: 1px solid #e5e7eb;
    }

    .error-banner {
      display: none;
      padding: 12px 14px;
      margin: 10px 0 0;
      border-radius: 12px;
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fecaca;
      font-weight: 600;
    }

    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal-box {
      background: #fff;
      padding: 24px;
      border-radius: 12px;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
    }

    .modal-title {
      font-size: 18px;
      font-weight: 700;
      margin-bottom: 12px;
      color: #bf0e0e;
      /* Warning color */
    }

    .modal-message {
      font-size: 15px;
      color: #334155;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .modal-actions {
      display: flex;
      gap: 12px;
      justify-content: center;
    }

    .btn-modal-cancel {
      background: #e2e8f0;
      color: #334155;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    .btn-modal-confirm {
      background: #bf0e0e;
      color: #fff;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
    }

    /* Print: allow multi-page flow - optimized for minimal header space */
    @media print {
      body * {
        visibility: hidden;
      }

      #printSection,
      #printSection * {
        visibility: visible !important;
      }

      #printSection {
        position: static !important;
        left: auto !important;
        top: auto !important;
        width: 100% !important;
        max-width: 100% !important;
        height: auto !important;
        overflow: visible !important;
        padding: 0 !important;
        margin: 0 !important;
        background: white !important;
        box-sizing: border-box !important;
      }

      /* Minimize print header spacing */
      #printSection>div:first-child {
        padding: 2px 0 !important;
        margin-bottom: 4px !important;
        border-bottom: 1px solid #000 !important;
      }

      .no-print {
        display: none !important;
      }

      .print-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }

      canvas {
        width: 100% !important;
        height: 300px !important;
        max-width: 100% !important;
      }

      .page-break {
        break-before: page;
        page-break-before: always;
      }

      .avoid-break {
        break-inside: avoid;
        page-break-inside: avoid;
      }

      #printTitle {
        font-size: 14px !important;
        margin-bottom: 2px !important;
        padding: 0 !important;
      }

      #printDate {
        font-size: 9px !important;
        margin-bottom: 2px !important;
        padding: 0 !important;
      }

      #printMeta {
        font-size: 9px !important;
        line-height: 1.2 !important;
        margin-bottom: 4px !important;
        padding: 0 !important;
      }

      #printMeta div {
        margin: 0 !important;
        padding: 0 !important;
      }

      #printMetrics {
        margin: 4px 0 !important;
        gap: 4px !important;
        flex-wrap: nowrap !important;
        /* Force single row */
        display: flex !important;
        align-items: stretch !important;
      }

      .print-metric {
        padding: 4px 6px !important;
        border-radius: 4px !important;
        border: 1px solid #ccc !important;
        background: #f1f5f9 !important;
        min-width: 0 !important;
        /* Allow shrinking */
        flex: 1 1 0px !important;
        /* Distribute evenly */
        text-align: center !important;
        color: #333 !important;
        /* Changed from white to a darker color for contrast on light background */
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }

      .print-metric .label {
        font-size: 8px !important;
        opacity: 1 !important;
        line-height: 1.1 !important;
      }

      .print-metric .value {
        font-size: 12px !important;
        font-weight: 800 !important;
        margin-top: 1px !important;
      }

      .makePrintChartCard {
        padding: 2px !important;
        margin-bottom: 4px !important;
      }

      .makePrintChartCard h3 {
        font-size: 11px !important;
        margin: 1px 0 !important;
      }

      table {
        font-size: 10px !important;
      }

      th,
      td {
        padding: 4px 6px !important;
      }

      #printChartsContainer {
        margin-top: 4px !important;
      }

      #printTablesContainer {
        margin-top: 4px !important;
      }

      /* Minimize page margins for print */
      @page {
        margin: 0.3cm 0.5cm !important;
        size: A4 !important;
      }

      * {
        -webkit-print-color-adjust: exact !important;
        print-color-adjust: exact !important;
      }
    }

    /* Login & Config Styles */
    .container-center {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }

    .login-card {
      background: white;
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 400px;
      text-align: center;
    }

    .login-title {
      font-size: 24px;
      font-weight: 700;
      color: #2c3e50;
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 20px;
      text-align: left;
    }

    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #34495e;
    }

    .form-input {
      width: 100%;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      box-sizing: border-box;
      transition: border-color 0.3s;
    }

    .form-input:focus {
      border-color: #3498db;
      outline: none;
    }

    .btn-block {
      width: 100%;
      margin: 10px 0;
    }

    .config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .config-card {
      background: #f8fafc;
      padding: 20px;
      border-radius: 15px;
      border: 1px solid #e2e8f0;
    }

    .config-textarea {
      width: 100%;
      height: 120px;
      padding: 12px;
      border: 1px solid #cbd5e1;
      border-radius: 10px;
      font-family: inherit;
      resize: vertical;
      box-sizing: border-box;
    }

    .config-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      border-bottom: 2px solid #e0e0e0;
      padding-bottom: 15px;
    }

    /* Mobile Warning Banner */
    .mobile-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
      color: white;
      padding: 12px 20px;
      text-align: center;
      font-weight: 600;
      font-size: 14px;
      z-index: 10000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      animation: slideDown 0.4s ease-out;
    }

    @keyframes slideDown {
      from {
        transform: translateY(-100%);
      }

      to {
        transform: translateY(0);
      }
    }

    .mobile-warning-icon {
      font-size: 18px;
      margin-right: 8px;
    }

    .mobile-warning-close {
      position: absolute;
      right: 15px;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 16px;
      line-height: 1;
      transition: background 0.2s;
    }

    .mobile-warning-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Show mobile warning on tablets and mobile devices */
    @media (max-width: 1024px) {
      .mobile-warning {
        display: block;
      }

      body {
        padding-top: 50px;
        /* Add padding to prevent content from being hidden behind warning */
      }
    }
  </style>
</head>

<body>
  <!-- Mobile Warning Banner -->
  <div class="mobile-warning" id="mobileWarning">
    <span class="mobile-warning-icon">⚠️</span>
    For the best experience, please use a desktop or laptop to view this application.
    <button class="mobile-warning-close"
      onclick="document.getElementById('mobileWarning').style.display='none'">×</button>
  </div>

  <!-- LOGIN VIEW -->
  <div id="loginView" class="container-center">
    <div class="login-card">
      <div class="login-title">SpinQ Login</div>
      <div class="form-group">
        <label class="form-label">User ID</label>
        <input type="text" id="loginUser" class="form-input" placeholder="Enter User ID">
      </div>
      <div class="form-group">
        <label class="form-label">Password</label>
        <input type="password" id="loginPass" class="form-input" placeholder="Enter Password">
      </div>
      <div id="loginError" style="color: #e74c3c; margin-bottom: 15px; display: none;">Invalid credentials</div>
      <button class="btn-start btn-block" onclick="handleLogin()">Login</button>
      <div style="margin-top: 15px; font-size: 14px; color: #7f8c8d;">
        No account? <a href="#" onclick="toggleSignup()" style="color: #3498db; text-decoration: none;">Create one</a>
      </div>
    </div>
  </div>

  <div id="signupView" class="container-center" style="display: none;">
    <div class="login-card">
      <div class="login-title">Create Account</div>
      <div class="form-group">
        <label class="form-label">New User ID</label>
        <input type="text" id="signupUser" class="form-input" placeholder="Choose User ID">
      </div>
      <div class="form-group">
        <label class="form-label">Password</label>
        <input type="password" id="signupPass" class="form-input" placeholder="Choose Password">
      </div>
      <button class="btn-start btn-block" onclick="handleSignup()">Create Account</button>
      <div style="margin-top: 15px; font-size: 14px; color: #7f8c8d;">
        <a href="#" onclick="toggleSignup()" style="color: #3498db; text-decoration: none;">Back to Login</a>
      </div>
    </div>
  </div>

  <!-- CONFIGURATION VIEW -->
  <div id="configView" class="container" style="display: none;">
    <div class="config-header">
      <h2 style="margin: 0;">System Configuration</h2>
      <div>
        <span id="configSaveStatus"
          style="color: #27ae60; font-weight: 600; margin-right: 15px; opacity: 0; transition: opacity 0.5s;">Saved!</span>
        <button class="btn-muted" onclick="exitConfig()">Back to Test</button>
      </div>
    </div>
    <div class="config-grid">
      <div class="config-card">
        <div class="card-title">Machines</div>
        <div class="card-subtitle">Separated by comma or new line</div>
        <textarea id="cfgMachines" class="config-textarea" placeholder="M1, M2, M3..."></textarea>
      </div>
      <div class="config-card">
        <div class="card-title">Products</div>
        <div class="card-subtitle">Separated by comma or new line</div>
        <textarea id="cfgProducts" class="config-textarea" placeholder="P1, P2..."></textarea>
      </div>
      <div class="config-card">
        <div class="card-title">Processes</div>
        <div class="card-subtitle">Separated by comma or new line</div>
        <textarea id="cfgProcesses" class="config-textarea" placeholder="Carding, Drawing..."></textarea>
      </div>
      <div class="config-card">
        <div class="card-title">Lot Numbers</div>
        <div class="card-subtitle">Separated by comma or new line</div>
        <textarea id="cfgLots" class="config-textarea" placeholder="L001, L002..."></textarea>
      </div>
      <div class="config-card">
        <div class="card-title">Yarn Counts</div>
        <div class="card-subtitle">Separated by comma or new line</div>
        <textarea id="cfgCounts" class="config-textarea" placeholder="30s, 40s..."></textarea>
      </div>
    </div>
  </div>

  <!-- MAIN APP VIEW -->
  <div id="mainAppView" class="container no-print" style="display: none;">
    <div class="header">
      <div style="min-width:180px; color:#7f8c8d; font-weight:600;">SPINWISELY</div>
      <div class="app-title">Count and Skein Strength Test</div>
      <div
        style="min-width: 180px; text-align: right; display: flex; align-items: center; justify-content: flex-end; gap: 10px;">
        <div class="current-date" id="currentDate" style="min-width: auto;"></div>
        <button class="btn-muted" onclick="openConfig()"
          style="padding: 6px 12px; font-size: 13px;">Configuration</button>
        <button class="btn-danger" onclick="logout()"
          style="margin: 0; padding: 6px 12px; font-size: 13px; display: none;">Logout</button>
      </div>
    </div>

    <div id="errorBanner" class="error-banner"></div>

    <h2>New Test</h2>

    <div class="header-inputs-row">
      <div class="input-card card-report">
        <div class="card-title">Report Number</div>
        <div class="card-subtitle">Auto-generated sequence</div>
        <input type="text" id="reportNumber" class="card-input" readonly value="Loading...">
      </div>

      <div class="input-card card-testdate">
        <div class="card-title">Test Date</div>
        <input type="date" id="testDate" class="card-input">
      </div>

      <div class="input-card card-operator">
        <div class="card-title">Operator Name</div>
        <input type="text" id="operatorName" class="card-input" placeholder="Select or type..." list="operatorList"
          required>
        <datalist id="operatorList"></datalist>
      </div>
    </div>

    <div style="margin-top: 20px;">
      <h3>Test Parameters</h3>
      <div class="header-inputs-row" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));">
        <div class="input-card">
          <label class="form-label">Machine</label>
          <select id="selMachine" class="card-input">
            <option value="">Select...</option>
          </select>
        </div>
        <div class="input-card">
          <label class="form-label">Product</label>
          <select id="selProduct" class="card-input">
            <option value="">Select...</option>
          </select>
        </div>
        <div class="input-card">
          <label class="form-label">Process</label>
          <select id="selProcess" class="card-input">
            <option value="">Select...</option>
          </select>
        </div>
        <div class="input-card">
          <label class="form-label">Lot Number</label>
          <select id="selLot" class="card-input">
            <option value="">Select...</option>
          </select>
        </div>
        <div class="input-card">
          <label class="form-label">Yarn Count</label>
          <select id="selCount" class="card-input">
            <option value="">Select...</option>
          </select>
        </div>
        <div class="input-card">
          <label class="form-label">Total Samples</label>
          <input type="number" id="txtSamples" class="card-input" value="10" min="1" step="1">
        </div>
        <div class="input-card">
          <label class="form-label">Tests per Sample</label>
          <input type="number" id="txtSubSamples" class="card-input" value="1" min="1" step="1">
        </div>
        <div class="input-card">
          <label class="form-label">Count Range Acceptable (+/- %)</label>
          <input type="number" id="txtRange" class="card-input" value="2.5" min="0.5" max="10.0" step="0.1"
            onchange="if(this.value < 0.5) this.value=0.5; if(this.value > 10) this.value=10;">
        </div>
      </div>
    </div>

    <div style="text-align:center; margin: 18px 0 10px;">
      <button class="btn-start" onclick="validateAndStart()">Start Entry</button>
      <button class="btn-simulate" onclick="validateAndSimulate()">Simulate Data</button>
      <button class="btn-danger" onclick="startNewTest()">Start New Test</button>
    </div>

    <div id="testSection" style="display:none;">
      <h2>Data Entry (Count & Strength)</h2>
      <div style="margin-bottom: 10px; display: flex; justify-content: flex-end; gap: 10px;">
        <button type="button" class="btn-primary" id="btnConnectScale" onclick="toggleScaleConnection()"
          style="background: #e67e22; padding: 8px 12px; font-size: 14px;">Connect Scale (RS232)</button>
        <button onclick="addSampleRow()" class="btn-start" style="padding: 8px 12px; font-size: 14px;">+ Add
          Row</button>
      </div>

      <!-- Main Data Table -->
      <table id="sliverTable">
        <thead>
          <tr>
            <th>Sample #</th>
            <th>Position #</th>
            <th>Weight (g)</th>
            <th>Source</th>
            <th>Count (Ne)</th>
            <th>Strength (lbs)</th>
            <th>CSP (Calc)</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody id="testTableBody"></tbody>
      </table>

      <div style="text-align:center; margin: 14px 0;">
        <button type="button" id="calcBtn" onclick="calculateResults()">Calculate Results</button>
        <button type="button" class="btn-save" id="saveBtn" disabled>Save Test</button>
        <button type="button" class="btn-print" id="printCurrentBtn" onclick="handlePrintClick('all')"
          style="opacity: 0.5; cursor: not-allowed;">Print Current</button>
        <button type="button" class="btn-print" id="printCountOnlyBtn" onclick="handlePrintClick('countOnly')"
          style="background: #27ae60; opacity: 0.5; cursor: not-allowed;">Print Current (Only Count Chart)</button>
        <button type="button" class="btn-print" id="printNoChartsBtn" onclick="handlePrintClick('noCharts')"
          style="background: #8e44ad; opacity: 0.5; cursor: not-allowed;">Print Current (No Charts)</button>
      </div>

      <!-- Metrics for Count/Strength -->
      <div class="metrics" id="metrics" style="display:none;">
      </div>

      <div style="margin-top:16px;">
        <!-- Charts placeholder -->
        <div id="chartsGrid" class="charts-grid"></div>
      </div>
    </div>

    <div class="saved-tests">
      <h2>Saved Tests (Summary by Product Averages)</h2>

      <div class="filter-section">
        <h3 style="margin: 0 0 15px; color: #1e293b; font-size: 16px;">Search & Filter Reports</h3>
        <div
          style="display: flex; flex-wrap: wrap; gap: 15px; align-items: flex-end; background: #fff; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">

          <div style="flex: 1; min-width: 150px;">
            <label class="filter-label" style="display:block; margin-bottom:5px;">Date Range</label>
            <select id="srchDateRange" class="filter-input" onchange="onSrchDateRangeChange();" style="width:100%;">
              <option value="all">All Dates</option>
              <option value="today">Today</option>
              <option value="week">This Week</option>
              <option value="month">This Month</option>
              <option value="custom">Custom Range...</option>
            </select>
          </div>

          <div id="srchCustomDates" style="display: none; flex: 2; min-width: 250px; gap: 10px;">
            <div style="flex:1;">
              <label class="filter-label" style="display:block; margin-bottom:5px;">From</label>
              <input type="date" id="srchDateFrom" class="filter-input" style="width:100%;">
            </div>
            <div style="flex:1;">
              <label class="filter-label" style="display:block; margin-bottom:5px;">To</label>
              <input type="date" id="srchDateTo" class="filter-input" style="width:100%;">
            </div>
          </div>

          <div style="flex: 1; min-width: 130px;">
            <label class="filter-label" style="display:block; margin-bottom:5px;">Machine</label>
            <select id="srchMachine" class="filter-input" style="width:100%;">
              <option value="">All</option>
            </select>
          </div>

          <div style="flex: 1; min-width: 130px;">
            <label class="filter-label" style="display:block; margin-bottom:5px;">Lot</label>
            <select id="srchLot" class="filter-input" style="width:100%;">
              <option value="">All</option>
            </select>
          </div>

          <div style="flex: 1; min-width: 130px;">
            <label class="filter-label" style="display:block; margin-bottom:5px;">Product</label>
            <select id="srchProduct" class="filter-input" style="width:100%;">
              <option value="">All</option>
            </select>
          </div>

          <div style="flex: 1; min-width: 130px;">
            <label class="filter-label" style="display:block; margin-bottom:5px;">Process</label>
            <select id="srchProcess" class="filter-input" style="width:100%;">
              <option value="">All</option>
            </select>
          </div>

          <div style="display:flex; gap:10px;">
            <button class="btn-start" onclick="applySrchFilters()"
              style="padding: 10px 20px; height: 38px; background:#3498db;">Apply Filters</button>
            <button class="btn-muted" onclick="clearSrchFilters()" style="padding: 10px 15px; height: 38px;">Clear
              All</button>
          </div>
        </div>
      </div>

      <div id="filteredResultsPanel"
        style="display: none; margin: 20px 0; padding: 16px; background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
          <h3 style="margin: 0;">Filtered Results (Grouped by Product)</h3>
          <button class="btn-muted" onclick="closeFilteredResults()"
            style="padding: 6px 12px; font-size: 13px;">Close</button>
        </div>
        <div id="filteredMetrics" class="metrics" style="margin-bottom: 16px;"></div>
        <div id="filteredChartsGrid" class="charts-grid"></div>
        <div style="margin-top: 16px; display: flex; gap: 12px; align-items: center;">
          <button class="btn-print" onclick="printFilteredResults()" style="padding: 8px 16px; font-size: 14px;">Print
            Filtered Results</button>
          <span style="color: #666; font-size: 13px;">(Includes charts and sorted data table)</span>
        </div>
      </div>

      <div class="action-row">
        <button class="btn-danger" onclick="deleteSelected()" id="deleteBtn" style="display:none;">Delete
          Selected</button>
        <button class="btn-print" onclick="printSelected()" id="printSelectedBtn" style="display:none;">Print Selected
          (Combined)</button>
        <button class="btn-start" onclick="viewCombinedData()" id="viewCombinedBtn"
          style="display:none; background:#3498db;">View Combined Data</button>
        <button class="btn-save" onclick="exportToExcel()" id="exportExcelBtn"
          style="display:inline-block; background:#27ae60;">Export to Excel</button>
        <button class="btn-print" onclick="exportToPDF()" id="exportPDFBtn"
          style="display:inline-block; background:#e67e22;">Export to PDF</button>
      </div>

      <!-- Combined View Panel -->
      <div id="combinedDetailsPanel" class="details-panel"
        style="display:none; margin: 20px 0; border:2px solid #3498db;">
        <div class="details-header"
          style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:1px solid #e2e8f0; padding-bottom:12px;">
          <h2 style="margin:0; font-size:20px; color:#1e293b;">Combined Data Analysis</h2>
          <button class="btn-muted" onclick="closeCombinedDetails()">Close Analysis</button>
        </div>

        <div id="combinedMetrics"
          style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:15px; margin-bottom:25px;">
          <!-- Metrics injected here -->
        </div>

        <div class="charts-grid"
          style="display:grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap:20px; min-height: 400px;">
          <div id="combined_avg_chart_container"></div>
          <div id="combined_single_chart_container"></div>
        </div>
      </div>

      <table id="savedTable">
        <thead>
          <tr>
            <th style="width:30px;"><input type="checkbox" onchange="toggleSelectAll(this)"></th>
            <th onclick="sortSavedTests('dateTime')" style="cursor:pointer;">Date Time <span id="sort-dateTime"></span>
            </th>
            <th onclick="sortSavedTests('reportNumber')" style="cursor:pointer;">Report # <span
                id="sort-reportNumber"></span></th>
            <th onclick="sortSavedTests('machine')" style="cursor:pointer;">Machine <span id="sort-machine"></span></th>
            <th onclick="sortSavedTests('product')" style="cursor:pointer;">Product <span id="sort-product"></span></th>
            <th onclick="sortSavedTests('process')" style="cursor:pointer;">Process <span id="sort-process"></span></th>
            <th onclick="sortSavedTests('lotNumber')" style="cursor:pointer;">Lot <span id="sort-lotNumber"></span></th>
            <th>Count</th>
            <th>Avg count</th>
            <th>Count CV%</th>
            <th>Avg Strength</th>
            <th>Avg CSP</th>
            <th>Out of limit</th>
            <th onclick="sortSavedTests('sampleCount')" style="cursor:pointer;">No. Samples <span
                id="sort-sampleCount"></span></th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody id="savedList"></tbody>
      </table>

      <div style="margin-top:20px; display:flex; justify-content:center;">
        <button class="btn-muted" onclick="clearSrchFilters()" style="padding: 10px 30px;">Clear All Filters</button>
      </div>
    </div> <!-- End container -->

    <div id="saveConfirmModal" class="modal-overlay">
      <div class="modal-box">
        <div class="modal-title">Warnings Found</div>
        <div class="modal-message" id="saveConfirmMessage"></div>
        <div class="modal-actions">
          <button type="button" class="btn-modal-cancel" id="btnModalCancel">Go Back</button>
          <button type="button" class="btn-modal-confirm" id="btnModalConfirm">Continue Saving</button>
        </div>
      </div>
    </div>

  </div>

  <!-- PRINT SECTION -->
  <div id="printSection"
    style="display:none; position:absolute; left:-9999px; top:0; width:100%; background:white; padding:0;">
    <div
      style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #000; padding:2px 0; margin-bottom:3px; box-sizing:border-box;">
      <div style="font-weight:800; font-size:11px; flex-shrink:0;">SPINWISELY</div>
      <div
        style="font-weight:900; font-size:14px; flex:1; text-align:center; padding:0 4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;"
        id="printTitle">SpinQ Report Monitoring</div>
      <div id="printDate"
        style="color:#555; font-size:9px; flex-shrink:0; text-align:right; max-width:100px; overflow:hidden; text-overflow:ellipsis;">
      </div>
    </div>

    <div id="printMeta" style="line-height:1.2; margin-bottom: 3px; font-size:9px;"></div>

    <div id="printMetrics" style="display:flex; gap:6px; justify-content:center; margin: 4px 0; flex-wrap:wrap;">
    </div>

    <div id="printChartsContainer"></div>

    <div id="printTablesContainer" style="margin-top: 18px;"></div>
  </div>

  <script>
    // -----------------------------
    // Safety banner
    // -----------------------------
    function showError(msg) {
      const el = document.getElementById('errorBanner');
      el.style.display = 'block';
      el.textContent = msg;
    }

    if (!window.Chart) {
      showError("Chart.js did not load. If your network blocks cdn.jsdelivr.net or you are offline, download Chart.js locally and reference it from a local file.");
    }

    // -----------------------------
    // Custom plugin to draw vertical lines (Mean/LCL/UCL + optional Target)
    // -----------------------------
    const limitLinesPlugin = {
      id: 'limitLinesPlugin',
      afterDatasetsDraw(chart, args, opts) {
        if (!opts || !opts.lines || !opts.lines.length) return;
        const { ctx, chartArea, scales } = chart;
        const xScale = scales.x;
        if (!xScale) return;

        // Detect if this is a print chart (canvas ID starts with "print_")
        const isPrint = chart.canvas.id && chart.canvas.id.startsWith('print_');
        const fontSize = isPrint ? 17 : 12;
        const labelHeight = isPrint ? 22 : 18;
        const labelPad = isPrint ? 6 : 4;
        const printFontFamily = 'Arial, sans-serif';

        ctx.save();
        ctx.lineWidth = isPrint ? 3 : 2;

        // Sort lines to draw Target first (if present), then Mean, then LCL/UCL
        const sortedLines = [...opts.lines].sort((a, b) => {
          const aIsTarget = a.label && a.label.startsWith('Target');
          const bIsTarget = b.label && b.label.startsWith('Target');
          const aIsMean = a.label && a.label.startsWith('Mean');
          const bIsMean = b.label && b.label.startsWith('Mean');
          if (aIsTarget && !bIsTarget) return -1;
          if (!aIsTarget && bIsTarget) return 1;
          if (aIsMean && !bIsMean && !aIsTarget && !bIsTarget) return 1;
          if (!aIsMean && bIsMean && !aIsTarget && !bIsTarget) return -1;
          return 0;
        });

        for (const ln of sortedLines) {
          const xPix = xScale.getPixelForValue(ln.value);
          if (!isFinite(xPix)) continue;

          ctx.strokeStyle = ln.color || '#111827';
          if (ln.dash && ln.dash.length) ctx.setLineDash(ln.dash); else ctx.setLineDash([]);

          ctx.beginPath();
          ctx.moveTo(xPix, chartArea.top);
          ctx.lineTo(xPix, chartArea.bottom);
          ctx.stroke();

          const label = ln.label || '';
          if (label) {
            ctx.setLineDash([]);
            ctx.font = isPrint ? `bold ${fontSize}px ${printFontFamily}` : `${fontSize}px bold Segoe UI, Arial`;

            const w = ctx.measureText(label).width + labelPad * 2;
            const h = labelHeight;
            const bx = Math.min(Math.max(xPix + 6, chartArea.left + 2), chartArea.right - w - 2);

            // Offset Mean label lower than Target to avoid overlap
            const isMean = label.startsWith('Mean');
            const isTarget = label.startsWith('Target');
            const verticalOffset = isMean ? (labelHeight + 2) : 0;
            const by = chartArea.top + 2 + verticalOffset;

            ctx.fillStyle = ln.labelBg || (ln.color || '#111827');
            ctx.fillRect(bx, by, w, h);

            ctx.fillStyle = '#ffffff';
            ctx.fillText(label, bx + labelPad, by + (isPrint ? 16 : 13));
          }
        }
        ctx.restore();
      }
    };

    if (window.Chart && typeof Chart.register === 'function') {
      Chart.register(limitLinesPlugin);
    }

    // -----------------------------
    // Auth & Config Logic
    // -----------------------------
    const USERS_KEY = 'spinQ_users';
    const CONFIG_KEY = 'spinQ_config';

    function initDefaults() {
      let config = {};
      try {
        config = JSON.parse(localStorage.getItem(CONFIG_KEY) || '{}');
      } catch (e) { }

      let changed = false;
      const defaults = {
        machines: 'S101',
        products: 'Carded',
        processes: 'Spinning',
        lots: 'Lot 001',
        counts: 'Ne 30'
      };

      for (const [key, val] of Object.entries(defaults)) {
        if (!config[key] || config[key].trim() === '') {
          config[key] = val;
          changed = true;
        }
      }

      if (changed) {
        localStorage.setItem(CONFIG_KEY, JSON.stringify(config));
      }
    }

    function getUsers() {
      try { return JSON.parse(localStorage.getItem(USERS_KEY) || '{}'); } catch { return {}; }
    }

    function saveUsers(users) {
      localStorage.setItem(USERS_KEY, JSON.stringify(users));
    }

    function checkLogin() {
      // FORCE LOGIN (Soft Bypass)
      const isLoggedIn = true;

      // Auto-set user if missing
      if (!sessionStorage.getItem('spinQ_currentUser')) {
        sessionStorage.setItem('spinQ_currentUser', 'admin');
      }

      const loginView = document.getElementById('loginView');
      const signupView = document.getElementById('signupView');
      const mainAppView = document.getElementById('mainAppView');
      const configView = document.getElementById('configView');

      if (loginView) loginView.style.display = 'none';
      if (signupView) signupView.style.display = 'none';
      if (mainAppView) mainAppView.style.display = 'none';
      if (configView) configView.style.display = 'none';

      // Always show Main App
      if (mainAppView) mainAppView.style.display = 'block';
      populateMainDropdowns();
    }

    function handleLogin() {
      console.log("Attempting login...");
      const userInput = document.getElementById('loginUser');
      const passInput = document.getElementById('loginPass');

      const user = userInput.value.trim();
      const pass = passInput.value.trim();

      if (!user || !pass) {
        alert("Please enter both User ID and Password");
        return;
      }

      let users = getUsers();

      // Auto-seed if no users exist
      if (Object.keys(users).length === 0) {
        console.log("No users found. Seeding admin/1234.");
        users = { 'admin': '1234' };
        saveUsers(users);
      }

      if (users[user] && users[user] === pass) {
        console.log("Login successful for:", user);
        sessionStorage.setItem('spinQ_isLoggedIn', 'true');
        sessionStorage.setItem('spinQ_currentUser', user);
        checkLogin();

        // Clear inputs
        userInput.value = '';
        passInput.value = '';
        document.getElementById('loginError').style.display = 'none';
      } else {
        console.warn("Login failed for:", user);
        const err = document.getElementById('loginError');
        err.style.display = 'block';
        err.textContent = "Invalid User ID or Password";
      }
    }

    function handleSignup() {
      const user = document.getElementById('signupUser').value.trim();
      const pass = document.getElementById('signupPass').value.trim();

      if (!user || !pass) return alert("Please enter both User ID and Password");

      const users = getUsers();
      if (users[user]) return alert("User ID already exists");

      users[user] = pass;
      saveUsers(users);
      alert("Account created! Please login.");
      toggleSignup(); // Back to login
    }

    function toggleSignup() {
      const login = document.getElementById('loginView');
      const signup = document.getElementById('signupView');
      if (login.style.display === 'none') {
        login.style.display = 'flex';
        signup.style.display = 'none';
      } else {
        login.style.display = 'none';
        signup.style.display = 'flex';
      }
      // Clear inputs
      document.querySelectorAll('.form-input').forEach(i => i.value = '');
      document.getElementById('loginError').style.display = 'none';
    }

    function logout() {
      sessionStorage.removeItem('spinQ_isLoggedIn');
      checkLogin();
    }

    // Configuration
    function openConfig() {
      document.getElementById('mainAppView').style.display = 'none';
      document.getElementById('configView').style.display = 'block';
      loadConfig();
    }

    function exitConfig() {
      document.getElementById('configView').style.display = 'none';
      document.getElementById('mainAppView').style.display = 'block';
      // Reload page to apply changes or just continue
      // For simplicity, we can reload to ensure dropdowns are populated freshly if we change them
      // But for better UX, we'll try to just return. The dropdowns need to be populated.
      populateMainDropdowns();
    }

    function loadConfig() {
      try {
        const config = JSON.parse(localStorage.getItem(CONFIG_KEY) || '{}');
        document.getElementById('cfgMachines').value = config.machines || '';
        document.getElementById('cfgProducts').value = config.products || '';
        document.getElementById('cfgProcesses').value = config.processes || '';
        document.getElementById('cfgLots').value = config.lots || '';
        document.getElementById('cfgCounts').value = config.counts || '';
      } catch { }
    }

    function saveConfig() {
      const config = {
        machines: document.getElementById('cfgMachines').value,
        products: document.getElementById('cfgProducts').value,
        processes: document.getElementById('cfgProcesses').value,
        lots: document.getElementById('cfgLots').value,
        counts: document.getElementById('cfgCounts').value
      };
      localStorage.setItem(CONFIG_KEY, JSON.stringify(config));

      const status = document.getElementById('configSaveStatus');
      status.style.opacity = '1';
      setTimeout(() => status.style.opacity = '0', 2000);
    }

    // Parse config string to array options
    function getConfigOptions(key) {
      try {
        const config = JSON.parse(localStorage.getItem(CONFIG_KEY) || '{}');
        const str = config[key] || '';
        // Split by comma or newline
        return str.split(/[\n,]+/).map(s => s.trim()).filter(s => s.length > 0);
      } catch { return []; }
    }

    // Populate Main Dropdowns (Will be called by checking login or init)
    // Populate Main Dropdowns (Will be called by checking login or init)
    function populateMainDropdowns() {
      const machines = getConfigOptions('machines');
      const products = getConfigOptions('products');
      const processes = getConfigOptions('processes');
      const lots = getConfigOptions('lots');
      const counts = getConfigOptions('counts');

      function fill(id, arr) {
        const el = document.getElementById(id);
        if (!el) return;
        // maintain selection if possible
        const current = el.value;
        el.innerHTML = '<option value="">Select...</option>' +
          arr.map(opt => `<option value="${opt}">${opt}</option>`).join('');
        if (arr.includes(current)) el.value = current;
      }

      fill('selMachine', machines);
      fill('selProduct', products);
      fill('selProcess', processes);
      fill('selLot', lots);
      fill('selCount', counts);
    }

    // Override validateAndStart
    function validateAndStart() {
      const report = document.getElementById('reportNumber').value;
      const operator = document.getElementById('operatorName').value;
      const machine = document.getElementById('selMachine').value;
      const product = document.getElementById('selProduct').value;
      const count = document.getElementById('selCount').value;

      // New params
      const totalSamples = parseInt(document.getElementById('txtSamples').value) || 10;
      const subsamples = parseInt(document.getElementById('txtSubSamples').value) || 1;

      if (!operator) return alert("Please select an operator.");
      if (!machine) return alert("Please select a Machine.");
      if (!product) return alert("Please select a Product.");
      if (!count) return alert("Please select Yarn Count.");

      // Save operator
      saveOperator(operator);

      document.getElementById('testSection').style.display = 'block';
      // Buttons always visible - controlled via disabled attribute
      document.getElementById('saveBtn').disabled = true; // Enable after calculation
      // printCurrentBtn stays visible

      // Initialize table
      resetTable(totalSamples, subsamples);

      // Scroll to test section
      document.getElementById('testSection').scrollIntoView({ behavior: 'smooth' });
      // Reset saved state when starting new test
      isCurrentTestSaved = false;
      isTestSaved = false; // Reset global flag
      isDataCalculated = false;
      isDataModified = false;

      // Reset print buttons to dull state for new test
      const printBtns = [
        document.getElementById('printCurrentBtn'),
        document.getElementById('printCountOnlyBtn'),
        document.getElementById('printNoChartsBtn')
      ];

      printBtns.forEach(btn => {
        if (btn) {
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
        }
      });
    }

    function resetTable(totalSamples, subsamples) {
      const tbody = document.getElementById('testTableBody');
      tbody.innerHTML = '';
      for (let i = 1; i <= totalSamples; i++) {
        if (subsamples > 1) {
          for (let j = 1; j <= subsamples; j++) {
            addSampleRow(`${i}-${j}`);
          }
        } else {
          addSampleRow(i);
        }
      }
    }

    function addSampleRow(displayIndex) {
      const tbody = document.getElementById('testTableBody');
      // If no index provided, autoincrement based on last row
      let idx = displayIndex;
      if (!idx) {
        const rows = tbody.querySelectorAll('tr');
        const lastRow = rows[rows.length - 1];
        if (lastRow) {
          // Try to parse number, or just increment length
          idx = rows.length + 1;
        } else {
          idx = 1;
        }
      }

      const tr = document.createElement('tr');
      tr.innerHTML = `
            <td>${idx}</td>
            <td><input type="text" class="card-input pos-val" placeholder="#"></td>
            <td><input type="number" class="card-input weight-val scale-input" id="weight_${idx}" oninput="updateSource(this); calcRow(this)" step="0.0001" onfocus="setActiveInput(this)"></td>
            <td class="source-cell" style="font-size: 11px; color: #7f8c8d; text-align: center;">Manual</td>
            <td class="count-val" style="font-weight:bold;">-</td>
            <td><input type="number" class="card-input strength-val" oninput="calcRow(this)" step="0.1"></td>
            <td class="csp-val" style="font-weight:bold;">-</td>
            <td class="status-cell">-</td>
          `;
      tbody.appendChild(tr);
    }

    function calcRow(input) {
      const row = input.closest('tr');
      const weightVal = parseFloat(row.querySelector('.weight-val').value);
      const strengthVal = parseFloat(row.querySelector('.strength-val').value);

      const countCell = row.querySelector('.count-val');
      const cspCell = row.querySelector('.csp-val');

      // 1. Calculate Count (Ne) from Weight (g)
      // Standard Lea Length = 120 yards.
      // Count = 64.8 / Grams

      let count = null;
      if (isFinite(weightVal) && weightVal > 0) {
        count = 64.8 / weightVal;
        countCell.textContent = count.toFixed(2);
      } else {
        countCell.textContent = '-';
      }

      // 2. Calculate CSP only if Strength and Count are present
      if (count !== null && isFinite(strengthVal)) {
        const csp = Math.round(count * strengthVal);
        cspCell.textContent = csp;
      } else {
        cspCell.textContent = '-';
      }
      isDataCalculated = false;
      isDataModified = true; // Mark data as modified when user edits

      // Enable Save button when data is modified (needs recalculation + save)
      const saveBtn = document.getElementById('saveBtn');
      if (saveBtn && isDataCalculated) saveBtn.disabled = false;

      triggerAutoCalc();
    }

    // Handle Print button click with auto-calculate
    // Handle Print button click with auto-calculate
    function handlePrintClick(mode = 'all') {
      // Check if saved first
      if (!isCurrentTestSaved) {
        alert("Save results first");
        return;
      }

      if (isDataModified || !isDataCalculated) {
        console.log("Auto-calculating before print since data changed...");
        calculateResults();
      }
      // Proceed with print - pass mode to control which charts to show
      printCurrent(mode);
    }

    const triggerAutoCalc = debounce(() => {
      // Only auto-calc if we have enough data? 
      // calculateResults handles empty data gracefully (alerts or logs).
      // Since this is auto-calc, we should suppress alerts?
      // calculateResults has an alert on error.
      // I will let it run. If it errors often, user will know format is wrong.
      calculateResults();
    }, 800);

    function debounce(func, wait) {
      let timeout;
      return function (...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), wait);
      };
    }

    function calculateResults() {
      try {
        const rows = document.querySelectorAll('#testTableBody tr');
        let countSum = 0, strengthSum = 0, cspSum = 0;
        let n = 0;
        let counts = [], strengths = [], csps = [];

        rows.forEach(row => {
          // Get count from text content (calculated)
          const cText = row.querySelector('.count-val').textContent;
          const c = (cText !== '-' && cText !== '') ? parseFloat(cText) : null;

          const sVal = row.querySelector('.strength-val').value;
          const s = (sVal !== '') ? parseFloat(sVal) : null;

          const cspText = row.querySelector('.csp-val').textContent;
          const csp = (cspText !== '-' && cspText !== '') ? parseFloat(cspText) : null;

          if (c !== null && s !== null && isFinite(s) && csp !== null) {
            countSum += c; counts.push(c);
            strengthSum += s; strengths.push(s);
            cspSum += csp; csps.push(csp);
            n++;
          }
        });

        if (n === 0) return alert("No valid manual data entered.");

        const avgCount = (countSum / n).toFixed(2);
        const avgStrength = (strengthSum / n).toFixed(2);
        const avgCSP = (cspSum / n).toFixed(0);

        // Calculate CV% for Count
        let countCV = "0.00";
        if (n > 1) {
          const mean = parseFloat(avgCount);
          const variance = counts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (n - 1);
          const stdDev = Math.sqrt(variance);
          if (mean > 0) {
            countCV = ((stdDev / mean) * 100).toFixed(2);
          }
        }

        // Calculate limits FIRST (before metrics display) to determine if Avg Count is out of range
        const rangeInput = document.getElementById('txtRange');
        const rangeVal = (rangeInput && rangeInput.value) ? parseFloat(rangeInput.value) : 2.5;
        const selCountEl = document.getElementById('selCount');
        const selCountVal = selCountEl ? selCountEl.value : '';
        const valMatch = selCountVal.match(/[\d.]+/);
        const selCount = valMatch ? parseFloat(valMatch[0]) : NaN;
        const countTarget = (isFinite(selCount) && selCount > 0) ? selCount : null;

        console.log(`Debug Calc: Range=${rangeVal}, SelCountVal="${selCountVal}", Parsed=${selCount}, Target=${countTarget}`);

        // Calculate Limits based on Target (spec) or Mean (control)
        let lcl, ucl;
        if (countTarget) {
          lcl = countTarget * (1 - rangeVal / 100);
          ucl = countTarget * (1 + rangeVal / 100);
        } else {
          // Fallback to Mean if no target (CONTROL limits logic)
          const countMean = parseFloat(avgCount);
          lcl = countMean * (1 - rangeVal / 100);
          ucl = countMean * (1 + rangeVal / 100);
        }

        // Check if Avg Count is out of range for metric box coloring
        const avgCountNum = parseFloat(avgCount);
        const isCountOutOfRange = (avgCountNum < lcl || avgCountNum > ucl);
        const countMetricStyle = isCountOutOfRange ?
          'background-color: #ef4444 !important;' : '';

        // Check if CV% is out of acceptable range (> 1.5%)
        const cvNum = parseFloat(countCV);
        const isCVOutOfRange = cvNum > 1.5;
        const cvMetricStyle = isCVOutOfRange ?
          'background-color: #ef4444 !important;' : '';

        // Get table rows first (needed for out-of-limit calculation)
        const tableRows = document.querySelectorAll('#testTableBody tr');

        // Calculate % of readings outside limits
        let outOfLimitCount = 0;
        tableRows.forEach(row => {
          const countCell = row.querySelector('.count-val');
          const cVal = parseFloat(countCell.textContent);
          if (isFinite(cVal) && (cVal < lcl || cVal > ucl)) {
            outOfLimitCount++;
          }
        });
        const outOfLimitPercent = n > 0 ? ((outOfLimitCount / n) * 100).toFixed(1) : '0.0';
        const isOutOfLimitNonZero = parseFloat(outOfLimitPercent) > 0;
        const outOfLimitStyle = isOutOfLimitNonZero ?
          'background-color: #ef4444 !important;' : '';

        // Update metrics display with conditional red styling
        const metricsDiv = document.getElementById('metrics');
        metricsDiv.innerHTML = `
             <div class="metric" style="${countMetricStyle}"><div class="label">Avg Count</div><div class="value">${avgCount}</div></div>
             <div class="metric"><div class="label">Avg Strength</div><div class="value">${avgStrength}</div></div>
             <div class="metric"><div class="label">Avg CSP</div><div class="value">${avgCSP}</div></div>
             <div class="metric" style="${cvMetricStyle}"><div class="label">Count CV%</div><div class="value">${countCV}%</div></div>
             <div class="metric" style="${outOfLimitStyle}"><div class="label">Out of Limit</div><div class="value">${outOfLimitPercent}%</div></div>
          `;
        metricsDiv.style.display = 'flex';

        isDataCalculated = true;
        document.getElementById('saveBtn').disabled = false;

        // -----------------------------
        // Render Charts
        // -----------------------------
        destroyChartMap(chartInstances, 'chartsGrid');
        const chartsContainer = document.getElementById('chartsGrid');
        chartsContainer.style.display = 'grid'; // Ensure it's visible

        // 1. Count Chart (with User Defined Range) - limits already calculated above
        const countChartId = 'chart_count_dist';
        chartsContainer.appendChild(makeChartCard(`Count Distribution (Ne) - Limits +/-${rangeVal}%`, countChartId));
        const countMean = parseFloat(avgCount);
        // lcl/ucl already calculated above - no need to recalculate

        // Update Status Column (tableRows already defined above)
        tableRows.forEach(row => {
          const countCell = row.querySelector('.count-val');
          const statusCell = row.querySelector('.status-cell');
          const cVal = parseFloat(countCell.textContent);

          if (isFinite(cVal)) {
            if (cVal < lcl || cVal > ucl) {
              statusCell.textContent = 'OOC';
              statusCell.style.color = '#ef4444';
              statusCell.style.fontWeight = 'bold';
              row.style.backgroundColor = '#fef2f2'; // Light red bg
            } else {
              statusCell.textContent = 'OK';
              statusCell.style.color = '#10b981';
              statusCell.style.fontWeight = 'normal';
              row.style.backgroundColor = '';
            }
          } else {
            statusCell.textContent = '-';
          }
        });

        plotDistribution(countChartId, counts, countMean, lcl, ucl, 'Count Distribution', chartInstances, countTarget);

        // 2. Strength Chart
        const strengthChartId = 'chart_strength_dist';
        chartsContainer.appendChild(makeChartCard('Strength Distribution (lbs)', strengthChartId));
        const strengthMean = parseFloat(avgStrength);
        // No explicit target for strength in inputs, so use Mean +/- 10% (wider range for strength usually)
        const strengthLims = limitsFromMean(strengthMean, 10.0);
        plotDistribution(strengthChartId, strengths, strengthMean, strengthLims.lcl, strengthLims.ucl, 'Strength Distribution', chartInstances, null);

        // -----------------------------
        // POPULATE currentTest FOR SAVING
        // -----------------------------
        currentTest = {
          reportNumber: document.getElementById('reportNumber')?.value || '',
          operatorName: document.getElementById('operatorName')?.value || '',
          machineId: document.getElementById('selMachine')?.value || '',
          product: document.getElementById('selProduct')?.value || '',
          process: document.getElementById('selProcess')?.value || '',
          lotNumber: document.getElementById('selLot')?.value || '',
          yarnCount: document.getElementById('selCount')?.value || '',
          testDate: document.getElementById('testDate')?.value || '',
          dateTime: new Date().toLocaleString(),
          avgCount: avgCount,
          avgStrength: avgStrength,
          avgCSP: avgCSP,
          countCV: countCV,
          rangePercent: rangeVal,
          lcl: lcl.toFixed(2),
          ucl: ucl.toFixed(2),
          sampleCount: n,
          outOfLimitPercent: outOfLimitPercent,
          outOfLimitCount: outOfLimitCount,
          testType: 'Count & Strength',
          rawData: { counts, strengths, csps: csps }
        };

        console.log("✓ currentTest populated:", currentTest);

      } catch (e) {
        console.error(e);
        alert("Error calculating results: " + e.message);
      }
    }

    function saveTest() {
      if (!isDataCalculated) {
        // Auto-calculate if user forgot
        console.log("Auto-calculating results before save...");
        try {
          calculateResults();
        } catch (e) {
          return alert("Cannot save: Calculation failed. " + e.message);
        }
      }

      try {
        let reportNum = document.getElementById('reportNumber').value;
        const operator = document.getElementById('operatorName')?.value || "Unknown";
        const machine = document.getElementById('selMachine')?.value || "Unknown";
        const product = document.getElementById('selProduct')?.value || "Unknown";
        const count = document.getElementById('selCount')?.value || "Unknown";
        const process = document.getElementById('selProcess')?.value || "Unknown";

        if (!reportNum) throw new Error("Report number missing");

        // VERSION TRACKING LOGIC
        if (isTestSaved && isDataModified) {
          // This is a modification of a saved test - add/increment version suffix
          if (versionSuffix === 0) {
            // First modification - store base number and create -1
            baseReportNumber = reportNum;
            versionSuffix = 1;
          } else {
            // Subsequent modification - increment version
            versionSuffix++;
          }
          reportNum = `${baseReportNumber}-${versionSuffix}`;
          console.log(`Version tracking: ${baseReportNumber} → ${reportNum}`);
        } else if (!isTestSaved) {
          // Brand new test - reset versioning
          baseReportNumber = reportNum;
          versionSuffix = 0;
        }

        const rowsData = [];
        const rows = document.querySelectorAll('#testTableBody tr');

        if (rows.length === 0) {
          throw new Error("No data rows to save. Please add samples.");
        }

        rows.forEach((row, i) => {
          // Basic extraction with fallback
          rowsData.push({
            sample: row.cells[0]?.textContent || (i + 1).toString(),
            pos: row.querySelector('.pos-val')?.value || '',
            weight: row.querySelector('.weight-val')?.value || '',
            source: row.querySelector('.source-cell')?.textContent || 'Manual',
            count: row.querySelector('.count-val')?.textContent || '-',
            strength: row.querySelector('.strength-val')?.value || '',
            csp: row.querySelector('.csp-val')?.textContent || '-'
          });
        });

        // Metrics (Safely)
        let metrics = {};
        try {
          const metricsDiv = document.getElementById('metrics');
          const mValues = metricsDiv ? metricsDiv.querySelectorAll('.value') : [];
          metrics = {
            avgCount: mValues[0]?.textContent || '-',
            avgStrength: mValues[1]?.textContent || '-',
            avgCSP: mValues[2]?.textContent || '-',
            countCV: mValues[3]?.textContent || '-'
          };
        } catch (e) { console.warn("Metrics error", e); }

        const testRecord = {
          id: Date.now().toString(),
          reportNumber: reportNum, // Use versioned reportNum
          testDate: document.getElementById('testDate')?.value || new Date().toISOString().split('T')[0],
          dateTime: new Date().toLocaleString(),
          operatorName: operator,
          machine,
          product,
          process, // Captured from selProcess in calculateResults context
          lotNumber: document.getElementById('selLot')?.value || "Unknown",
          targetCount: count,
          rows: rowsData,
          metrics: metrics,
          // Explicit fields for table rendering
          avgCount: metrics.avgCount || '-',
          avgStrength: metrics.avgStrength || '-',
          avgCSP: metrics.avgCSP || '-',
          countCV: metrics.countCV || '-',
          outOfLimitCount: document.getElementById('metrics')?.querySelectorAll('.value')[4]?.textContent?.replace('%', '') || '0.0',
          testType: 'Count & Strength',
          rawData: (typeof currentTest !== 'undefined' && currentTest.rawData) ? JSON.parse(JSON.stringify(currentTest.rawData)) : null,
          rangePercent: (typeof currentTest !== 'undefined') ? currentTest.rangePercent : 2.5,
          lcl: (typeof currentTest !== 'undefined') ? currentTest.lcl : null,
          ucl: (typeof currentTest !== 'undefined') ? currentTest.ucl : null,
          yarnCount: count // Add for details view
        };

        // Save to Local Storage
        const saved = JSON.parse(localStorage.getItem('spinQ_countStrengthTests') || '[]');
        saved.push(testRecord);
        localStorage.setItem('spinQ_countStrengthTests', JSON.stringify(saved));

        // Render List Safe call
        if (typeof renderSavedTests === 'function') {
          renderSavedTests();
        }

        // Counter Update Logic (only for brand new tests, not versions)
        if (versionSuffix === 0) {
          let currentReport = parseInt(localStorage.getItem('spinQ_reportCounter') || '1000');
          if (isFinite(currentReport)) {
            currentReport++;
            localStorage.setItem('spinQ_reportCounter', currentReport);
            document.getElementById('reportNumber').value = currentReport;
            if (typeof setReportCounter === 'function') setReportCounter(currentReport); // Sync state if possible
          }
        } else {
          // Update display to show versioned number
          document.getElementById('reportNumber').value = reportNum;
        }

        // Update state flags
        isTestSaved = true;
        isDataModified = false; // Reset since we just saved
        isCurrentTestSaved = true; // Mark current test as saved

        // Disable save button until next modification
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) saveBtn.disabled = true;

        // Show print buttons after save - make them bright and clickable
        const printBtns = [
          document.getElementById('printCurrentBtn'),
          document.getElementById('printCountOnlyBtn'),
          document.getElementById('printNoChartsBtn')
        ];

        printBtns.forEach(btn => {
          if (btn) {
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
          }
        });

        // Lock all input fields to prevent editing after save
        document.querySelectorAll('#testTableBody .weight-val, #testTableBody .strength-val').forEach(input => {
          input.readOnly = true;
          input.style.backgroundColor = '#f3f4f6';
          input.style.cursor = 'not-allowed';
        });

        alert(`Success! Test saved as ${reportNum}. Input fields are now locked. Start a new test to edit data.`);

      } catch (e) {
        console.error("Save Test Error:", e);
        alert("Error saving test: " + e.message);
      }
    }




    function formatProductSummary(summaryByProduct) {
      const keys = Object.keys(summaryByProduct || {});
      if (!keys.length) return '-';
      return keys
        .sort((a, b) => a.localeCompare(b))
        .map(p => `${p}: ${summaryByProduct[p].meanCardAvg.toFixed(2)} (n=${summaryByProduct[p].cards})`)
        .join(' | ');
    }

    // -----------------------------
    // Saved Tests Management
    // -----------------------------
    function getSavedTests() {
      try {
        const stored = localStorage.getItem('spinQ_countStrengthTests');
        if (stored) {
          const parsed = JSON.parse(stored);
          if (Array.isArray(parsed)) return parsed;
        }
      } catch (e) { console.error("Error reading saved tests:", e); }
      return [];
    }

    function viewDetailsByRow(event, originalIndex) {
      event.preventDefault();
      event.stopPropagation();
      const saved = getSavedTests();
      const test = saved[originalIndex];
      if (!test) return;

      // If details already open for this exact row, close it (toggle)
      const existing = document.getElementById(`detail-row-${originalIndex}`);
      if (existing) {
        closeDetails();
      } else {
        openDetails(test, originalIndex);
      }
    }

    function onSavedSelectionChanged(changedCb) {
      const checkboxes = document.querySelectorAll('#savedList input[type="checkbox"]');
      const selected = Array.from(checkboxes).filter(cb => cb.checked);

      if (selected.length === 0) {
        // Clear all restrictions
        checkboxes.forEach(cb => {
          cb.disabled = false;
          cb.parentElement.parentElement.style.opacity = '1';
        });
      } else {
        // Lock to the first selected Lot
        const firstSelectedRow = selected[0].closest('tr');
        const targetLot = firstSelectedRow.getAttribute('data-lot');

        checkboxes.forEach(cb => {
          const row = cb.closest('tr');
          const lot = row.getAttribute('data-lot');
          if (lot !== targetLot) {
            cb.checked = false; // Uncheck any mismatched ones just in case
            cb.disabled = true;
            row.style.opacity = '0.4';
          } else {
            cb.disabled = false;
            row.style.opacity = '1';
          }
        });
      }

      const anyChecked = selected.length > 0;
      const multipleChecked = selected.length > 1;
      const deleteBtn = document.getElementById('deleteBtn');
      const printSelectedBtn = document.getElementById('printSelectedBtn');
      const viewCombinedBtn = document.getElementById('viewCombinedBtn');

      if (deleteBtn) deleteBtn.style.display = anyChecked ? 'inline-block' : 'none';
      if (printSelectedBtn) printSelectedBtn.style.display = anyChecked ? 'inline-block' : 'none';
      if (viewCombinedBtn) viewCombinedBtn.style.display = multipleChecked ? 'inline-block' : 'none';
    }

    function toggleSelectAll(master) {
      const checkboxes = document.querySelectorAll('#savedList input[type="checkbox"]');
      if (master.checked) {
        // Find the first non-disabled lot or use the first row's lot
        const firstRow = document.querySelector('#savedList tr');
        if (firstRow) {
          const targetLot = firstRow.getAttribute('data-lot');
          checkboxes.forEach(cb => {
            if (cb.closest('tr').getAttribute('data-lot') === targetLot) {
              cb.checked = true;
            } else {
              cb.checked = false;
            }
          });
        }
      } else {
        checkboxes.forEach(cb => cb.checked = false);
      }
      onSavedSelectionChanged();
    }

    function getSelectedSavedIndices() {
      const checkboxes = document.querySelectorAll('#savedList input[type="checkbox"]:checked');
      const selected = [];
      checkboxes.forEach(cb => {
        const row = cb.closest('tr');
        if (row && row.hasAttribute('data-original-index')) {
          const idx = parseInt(row.getAttribute('data-original-index'), 10);
          if (!isNaN(idx)) selected.push(idx);
        }
      });
      return selected;
    }

    function deleteSelected() {
      const selectedIndices = getSelectedSavedIndices();
      if (selectedIndices.length === 0) return;
      if (!confirm('Are you sure you want to delete the selected tests?')) return;

      const saved = getSavedTests();
      const selectedSet = new Set(selectedIndices);
      const kept = saved.filter((_, idx) => !selectedSet.has(idx));

      localStorage.setItem('spinQ_countStrengthTests', JSON.stringify(kept));
      renderSavedTests();
      if (typeof closeDetails === 'function') closeDetails();
    }

    function viewTestDetails(id) {
      alert("View Details feature: ID " + id);
    }



    function startNewTest() {
      if (confirm("Start a new test? Unsaved data will be lost.")) {
        // Reset version tracking for new test
        isTestSaved = false;
        isDataModified = false;
        baseReportNumber = null;
        versionSuffix = 0;

        document.getElementById('testSection').style.display = 'none';
        document.getElementById('testTableBody').innerHTML = '';
        document.getElementById('metrics').style.display = 'none';
        document.getElementById('reportNumber').value = "Loading...";
        document.getElementById('selMachine').value = "";
        document.getElementById('selProduct').value = "";
        document.getElementById('selLot').value = "";
        document.getElementById('selCount').value = "";
      }
    }

    // Attach Autosave to Textareas
    ['cfgMachines', 'cfgProducts', 'cfgProcesses', 'cfgLots', 'cfgCounts'].forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('input', () => {
          saveConfig();
        });
      }
    });

    // Initialize Auth
    window.addEventListener('DOMContentLoaded', () => {
      checkLogin();
    });

    // -----------------------------
    // Constants/state
    // -----------------------------
    const TOTAL_CARDS = 15;
    const COILERS_PER_CARD = 4;
    const PRODUCT_OPTIONS_BASE = ["Q tip", "Triple", "Organic", "Special"];
    const PRODUCT_DEFAULT = "";

    function getProductOptions() {
      const customName = document.getElementById('t_custom_name')?.value?.trim();
      const customTarget = parseFloat(document.getElementById('t_custom')?.value);
      const options = [...PRODUCT_OPTIONS_BASE];
      if (customName && isFinite(customTarget) && customTarget > 0) {
        options.push(customName);
      }
      return options;
    }

    function getProductColorClass(productName) {
      const name = (productName || '').toLowerCase().trim();
      if (name === 'q tip' || name === 'qtip') return 'qtip';
      if (name === 'triple') return 'triple';
      if (name === 'organic') return 'organic';
      if (name === 'special') return 'special';
      return 'custom';
    }

    let cardRows = [];
    let currentTest = null;
    let detailsTest = null;
    let hasUnsavedData = false;
    let isDataCalculated = false; // Track if data has been calculated (needs recalculation if changed)
    let isTestSaved = false; // Track if test has been saved (global flag)
    let isDataModified = false; // Track if user has modified data since last calculation
    let isCurrentTestSaved = false; // Track if current test has been saved saved
    let baseReportNumber = null; // Store base report number for versioning (e.g., "1018")
    let versionSuffix = 0; // Track version number (0 = no suffix, 1 = -1, 2 = -2, etc.)

    const chartInstances = new Map();
    const detailsChartInstances = new Map();
    const printChartInstances = new Map();

    // RS-232 Scale integration
    let scalePort = null;
    let scaleReader = null;
    let scaleConnected = false;
    let currentScaleValue = null;

    // -----------------------------
    // Storage
    // -----------------------------
    function getReportCounter() {
      try {
        const stored = localStorage.getItem('sliverReportCounter');
        if (stored) {
          const parsed = parseInt(stored, 10);
          if (!isNaN(parsed) && parsed > 1000) return parsed;
        }
      } catch (_) { }
      return 1000;
    }
    function setReportCounter(value) {
      try { localStorage.setItem('sliverReportCounter', String(value)); } catch (_) { }
    }


    function setSavedTests(tests) {
      try {
        localStorage.setItem('spinQ_countStrengthTests', JSON.stringify(tests));
      } catch (e) {
        throw e; // Bubble up error to saveTest
      }
    }

    // -----------------------------
    // Persistent Product Configs & Card Logic
    // -----------------------------
    // IDs of inputs to persist
    const PRODUCT_INPUT_IDS = [
      't_qtip', 'r_qtip', 'c_qtip',
      't_triple', 'r_triple', 'c_triple',
      't_organic', 'r_organic', 'c_organic',
      't_special', 'r_special', 'c_special',
      't_custom_name', 't_custom', 'r_custom', 'c_custom'
    ];

    function saveProductConfigs() {
      const data = {};
      PRODUCT_INPUT_IDS.forEach(id => {
        const el = document.getElementById(id);
        if (el) data[id] = el.value;
      });
      try {
        localStorage.setItem('sliverProductConfigs', JSON.stringify(data));
      } catch (_) { }
    }

    function loadProductConfigs() {
      try {
        const stored = localStorage.getItem('sliverProductConfigs');
        if (stored) {
          const data = JSON.parse(stored);
          PRODUCT_INPUT_IDS.forEach(id => {
            if (data[id] !== undefined) {
              const el = document.getElementById(id);
              if (el) el.value = data[id];
            }
          });
        }
      } catch (_) { }
    }

    // Parses "1-3, 5, 8-10" into [1, 2, 3, 5, 8, 9, 10]
    function parseCardRange(str) {
      const cards = new Set();
      if (!str) return [];

      // Split by comma
      const parts = str.split(',');
      for (const part of parts) {
        const p = part.trim();
        if (!p) continue;

        if (p.includes('-')) {
          const [startStr, endStr] = p.split('-');
          const s = parseInt(startStr, 10);
          const e = parseInt(endStr, 10);
          if (!isNaN(s) && !isNaN(e)) {
            const low = Math.min(s, e);
            const high = Math.max(s, e);
            for (let i = low; i <= high; i++) {
              if (i >= 1 && i <= TOTAL_CARDS) cards.add(i);
            }
          }
        } else {
          const val = parseInt(p, 10);
          if (!isNaN(val) && val >= 1 && val <= TOTAL_CARDS) {
            cards.add(val);
          }
        }
      }
      return Array.from(cards).sort((a, b) => a - b);
    }

    // Compile assignments: index 1..15 => { productName, target, range }
    function getCardAssignments() {
      const assignments = new Array(TOTAL_CARDS + 1).fill(null);

      // Helper to process product block
      function processProduct(nameId, targetId, rangeId, cardsId, defaultName) {
        const nameEl = document.getElementById(nameId);
        const targetEl = document.getElementById(targetId);
        const rangeEl = document.getElementById(rangeId);
        const cardsEl = document.getElementById(cardsId);

        const name = (nameId && nameEl) ? nameEl.value.trim() : defaultName;
        const target = targetEl ? targetEl.value : '';
        const range = rangeEl ? rangeEl.value : '5.0';
        const cardStr = cardsEl ? cardsEl.value : '';

        if (cardStr) {
          const cIds = parseCardRange(cardStr);
          cIds.forEach(cId => {
            assignments[cId] = { productName: name || defaultName, target, range };
          });
        }
      }

      processProduct(null, 't_qtip', 'r_qtip', 'c_qtip', 'Q tip');
      processProduct(null, 't_triple', 'r_triple', 'c_triple', 'Triple');
      processProduct(null, 't_organic', 'r_organic', 'c_organic', 'Organic');
      processProduct(null, 't_special', 'r_special', 'c_special', 'Special');
      processProduct('t_custom_name', 't_custom', 'r_custom', 'c_custom', 'Custom Product');

      return assignments;
    }

    // -----------------------------
    // Operator Persistence
    // -----------------------------
    function loadOperatorHistory() {
      try {
        const history = JSON.parse(localStorage.getItem('sliverOperatorHistory') || '[]');
        const lastOp = localStorage.getItem('sliverLastOperator');

        const dataList = document.getElementById('operatorList');
        if (dataList) {
          dataList.innerHTML = history.map(name => `<option value="${escapeHtml(name)}">`).join('');
        }

        if (lastOp) {
          document.getElementById('operatorName').value = lastOp;
        }
      } catch (_) { }
    }

    function saveOperator(name) {
      if (!name) return;
      try {
        localStorage.setItem('sliverLastOperator', name);

        let history = JSON.parse(localStorage.getItem('sliverOperatorHistory') || '[]');
        if (!history.includes(name)) {
          history.push(name);
          // keep history reasonable size? e.g. 50
          if (history.length > 50) history.shift();
          localStorage.setItem('sliverOperatorHistory', JSON.stringify(history));

          // update datalist immediately
          const dataList = document.getElementById('operatorList');
          if (dataList) {
            dataList.innerHTML = history.map(n => `<option value="${escapeHtml(n)}">`).join('');
          }
        }
      } catch (_) { }
    }

    // -----------------------------
    // Unsaved Data Warning
    // -----------------------------
    window.addEventListener('beforeunload', function (e) {
      if (isDataCalculated && !isCurrentTestSaved) {
        e.preventDefault();
        e.returnValue = 'You have unsaved test data. Are you sure you want to leave?';
        return e.returnValue;
      }
    });

    // -----------------------------
    // Detect Edit Attempts on Locked Fields  
    // -----------------------------
    document.addEventListener('click', function (e) {
      if (isCurrentTestSaved && (e.target.matches('.weight-val') || e.target.matches('.strength-val'))) {
        if (e.target.readOnly) {
          alert('This test has been saved and cannot be edited. Please start a new test to enter new data.');
        }
      }
    });

    // -----------------------------
    // Init
    // -----------------------------
    // Initialize
    window.onload = function () {
      initDefaults();
      // On load, apply any existing config (target, range etc.)
      try {
        loadProductConfigs(); // Load saved targets & card ranges
        loadOperatorHistory(); // Load operator defaults

        // Attach button listeners
        const calcBtn = document.getElementById('calcBtn');
        if (calcBtn) calcBtn.addEventListener('click', calculateResults);

        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) saveBtn.addEventListener('click', saveTest);

        const printCurrentBtn = document.getElementById('printCurrentBtn');
        if (printCurrentBtn) printCurrentBtn.addEventListener('click', printCurrent);

        // Modal Listeners
        const btnModalCancel = document.getElementById('btnModalCancel');
        const btnModalConfirm = document.getElementById('btnModalConfirm');
        if (btnModalCancel) {
          btnModalCancel.addEventListener('click', function () {
            document.getElementById('saveConfirmModal').style.display = 'none';
            // Scroll to defect if needed
            if (currentTest && currentTest.outOfControlCardNos && currentTest.outOfControlCardNos.length > 0) {
              const firstDefectiveCard = currentTest.outOfControlCardNos[0];
              const cardRow = document.getElementById(`cardRow_${firstDefectiveCard}`);
              if (cardRow) {
                cardRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                cardRow.style.transition = 'background-color 0.3s';
                cardRow.style.backgroundColor = '#fff3cd';
                setTimeout(() => { cardRow.style.backgroundColor = ''; }, 2000);
              }
            }
          });
        }
        if (btnModalConfirm) {
          btnModalConfirm.addEventListener('click', function () {
            document.getElementById('saveConfirmModal').style.display = 'none';
            finalizeSave();
          });
        }

        // Attach change listeners to auto-save
        PRODUCT_INPUT_IDS.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.addEventListener('change', saveProductConfigs);
        });

        let reportCounter = getReportCounter();
        reportCounter++;
        setReportCounter(reportCounter);
        document.getElementById('reportNumber').value = reportCounter;

        const today = new Date();
        const options = { day: '2-digit', month: 'short', year: 'numeric' };
        document.getElementById('currentDate').textContent = today.toLocaleDateString('en-GB', options);
        document.getElementById('printDate').textContent = today.toLocaleDateString('en-GB', options);

        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        const todayStr = `${yyyy}-${mm}-${dd}`;

        const minDate = new Date(today); minDate.setDate(today.getDate() - 7);
        const maxDate = new Date(today); maxDate.setDate(today.getDate() + 7);

        const dateInput = document.getElementById('testDate');
        dateInput.value = todayStr;
        dateInput.min = minDate.toISOString().split('T')[0];
        dateInput.max = maxDate.toISOString().split('T')[0];

        renderSavedTests();
        initializeFilters();

        // Check for scale support on page load
        if (!navigator.serial) {
          // Web Serial API not available - will show message when test section opens
        }

        // Add warning when trying to close tab with unsaved data
        window.addEventListener('beforeunload', function (e) {
          // Check if there's any entered data (at least one coiler value entered)
          const hasData = cardRows && cardRows.length > 0 &&
            cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));

          if (hasData) {
            // Modern browsers require setting returnValue and returning a value
            e.preventDefault();
            e.returnValue = 'Data not saved, do you wish to close the tab?';
            return e.returnValue;
          }
        });
      } catch (e) {
        showError("Initialization failed: " + (e && e.message ? e.message : String(e)));
      }
    };

    // -----------------------------
    // Targets (top inputs)
    // -----------------------------
    function getTargets() {
      const map = {
        "Q tip": parseFloat(document.getElementById('t_qtip').value),
        "Triple": parseFloat(document.getElementById('t_triple').value),
        "Organic": parseFloat(document.getElementById('t_organic').value),
        "Special": parseFloat(document.getElementById('t_special').value)
      };
      const out = {};
      for (const k of Object.keys(map)) {
        const v = map[k];
        out[k] = (isFinite(v) && v > 0) ? v : null;
      }
      // Add custom product if name and target are provided
      const customName = document.getElementById('t_custom_name')?.value?.trim();
      const customTarget = parseFloat(document.getElementById('t_custom')?.value);
      if (customName && isFinite(customTarget) && customTarget > 0) {
        out[customName] = customTarget;
      }
      return out;
    }

    function getAcceptableRanges() {
      const ranges = {
        "Q tip": parseFloat(document.getElementById('r_qtip')?.value || '5.0'),
        "Triple": parseFloat(document.getElementById('r_triple')?.value || '5.0'),
        "Organic": parseFloat(document.getElementById('r_organic')?.value || '5.0'),
        "Special": parseFloat(document.getElementById('r_special')?.value || '5.0')
      };
      // Validate ranges
      for (const k of Object.keys(ranges)) {
        const v = ranges[k];
        if (!isFinite(v) || v < 0.5 || v > 20) ranges[k] = 5.0;
      }
      // Add custom product range if custom product exists
      const customName = document.getElementById('t_custom_name')?.value?.trim();
      const customTarget = parseFloat(document.getElementById('t_custom')?.value);
      if (customName && isFinite(customTarget) && customTarget > 0) {
        // Legacy support or ignore
      }
      return ranges;
    }

    function getAcceptableRange(productNameIgnored) {
      // Always return the global setting from txtRange as requested
      const el = document.getElementById('txtRange');
      if (el && el.value) {
        const v = parseFloat(el.value);
        if (isFinite(v) && v > 0) return v;
      }
      return 2.5;
    }

    function formatTargets(targets) {
      // Show all products with targets, with 0.00 for products without target values
      const baseProducts = PRODUCT_OPTIONS_BASE;
      const parts = baseProducts.map(p => {
        const value = (targets && targets[p] !== null && targets[p] !== undefined && isFinite(targets[p]) && targets[p] > 0)
          ? Number(targets[p]).toFixed(2)
          : '0.00';
        return `${p}: ${value}`;
      });
      // Add custom product if it exists in targets
      if (targets) {
        for (const key of Object.keys(targets)) {
          if (!baseProducts.includes(key) && targets[key] !== null && targets[key] > 0) {
            parts.push(`${key}: ${Number(targets[key]).toFixed(2)}`);
          }
        }
      }
      if (!parts.length) return '-';
      return parts.join(' | ');
    }

    // -----------------------------
    // Validation / Start
    // -----------------------------
    function validateInputs() {
      const operatorName = document.getElementById('operatorName').value.trim();
      const testDate = document.getElementById('testDate').value;
      if (!operatorName || !testDate) {
        alert('Please fill in Operator Name and Test Date.');
        return false;
      }
      saveOperator(operatorName); // Save on successful validation
      return true;
    }

    function validateCardAssignments() {
      const allCards = [];
      const overlaps = new Set();

      const productInputs = [
        { id: 'c_qtip', name: 'Q tip' },
        { id: 'c_triple', name: 'Triple' },
        { id: 'c_organic', name: 'Organic' },
        { id: 'c_special', name: 'Special' },
        { id: 'c_custom', name: 'Custom Product' }
      ];

      productInputs.forEach(p => {
        const el = document.getElementById(p.id);
        if (el && el.value.trim()) {
          const cards = parseCardRange(el.value);
          cards.forEach(c => {
            if (allCards.includes(c)) {
              overlaps.add(c);
            }
            allCards.push(c);
          });
        }
      });

      if (overlaps.size > 0) {
        const sortedOverlaps = Array.from(overlaps).sort((a, b) => a - b);
        alert(`Error: Card(s) ${sortedOverlaps.join(', ')} are assigned to multiple products. Please correct assignments.`);
        return false;
      }
      return true;
    }

    /*
    function validateAndStart() {
      // Old logic replaced
    }
    */
    function validateAndStart_old() {
      if (!validateInputs()) return;
      if (!validateCardAssignments()) return;
      startEntry();
    }

    /*
    function validateAndSimulate() {
      // Old logic replaced
    }
    */
    function validateAndSimulate_old() {
      if (!validateInputs()) return;
      if (!validateCardAssignments()) return;
      // ...
    }

    function validateAndSimulate() {
      const machine = document.getElementById('selMachine').value;
      const product = document.getElementById('selProduct').value;
      const countStr = document.getElementById('selCount').value;

      if (!machine || !product || !countStr) {
        return alert("Please select Machine, Product, and Yarn Count first.");
      }

      // Start test (generates rows)
      validateAndStart();

      const targetCount = parseFloat(countStr) || 30;
      const targetWeight = 64.8 / targetCount;
      const targetStrength = 95;

      // Fill data
      const rows = document.querySelectorAll('#testTableBody tr');
      rows.forEach(row => {
        const wVal = targetWeight + (Math.random() - 0.5) * (targetWeight * 0.05);
        const sVal = targetStrength + (Math.random() - 0.5) * (targetStrength * 0.10);

        row.querySelector('.weight-val').value = wVal.toFixed(4);
        row.querySelector('.strength-val').value = sVal.toFixed(1);
        row.querySelector('.pos-val').value = Math.floor(Math.random() * 20) + 1;
        calcRow(row.querySelector('.weight-val'));
      });

      calculateResults();
    }


    function startNewSliverTest() {  // Renamed from startNewTest - for Sliver/Carding module
      // Check if there's any unsaved data
      const hasData = cardRows && cardRows.length > 0 &&
        cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));

      if (hasData || hasUnsavedData) {
        const confirmMessage = 'Warning: All unsaved data will be lost.\\n\\nDo you want to start a new test?';
        if (!confirm(confirmMessage)) {
          return; // User cancelled
        }
      }

      // Reset all form fields
      // Reset targets
      document.getElementById('t_qtip').value = '';
      document.getElementById('t_triple').value = '';
      document.getElementById('t_organic').value = '';
      document.getElementById('t_special').value = '';
      document.getElementById('t_custom').value = '';
      document.getElementById('t_custom_name').value = '';

      // Reset acceptable ranges to default (5.0)
      document.getElementById('r_qtip').value = '5.0';
      document.getElementById('r_triple').value = '5.0';
      document.getElementById('r_organic').value = '5.0';
      document.getElementById('r_special').value = '5.0';
      document.getElementById('r_custom').value = '5.0';

      // Reset operator name (do NOT reset if we want persistent default, but "Start New Test" implies fresh canvas)
      // Requirement: "last entered operator name should come as default when the page loaded next time"
      // Usually "Start New Test" clears everything for a fresh start. 
      // If user wants to keep operator, they can select from dropdown.
      // Let's clear it, but the autofill happens on page load.
      document.getElementById('operatorName').value = '';

      // Reset test date to today
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, '0');
      const dd = String(today.getDate()).padStart(2, '0');
      const todayStr = `${yyyy}-${mm}-${dd}`;
      document.getElementById('testDate').value = todayStr;

      // Get next report number
      let reportCounter = getReportCounter();
      reportCounter++;
      setReportCounter(reportCounter);
      document.getElementById('reportNumber').value = reportCounter;

      // Hide test section
      document.getElementById('testSection').style.display = 'none';

      // Reset all state variables
      cardRows = [];
      currentTest = null;
      hasUnsavedData = false;
      isDataCalculated = false;
      isTestSaved = false;

      // Reset buttons - COMMENTED OUT FOR ALWAYS-VISIBLE REQUIREMENT
      // document.getElementById('saveBtn').style.display = 'none';
      // document.getElementById('printCurrentBtn').style.display = 'none';

      // Clear charts
      destroyChartMap(chartInstances, 'chartsGrid');

      // Hide metrics
      document.getElementById('metrics').style.display = 'none';

      // Clear error banner
      document.getElementById('errorBanner').style.display = 'none';
    }

    function startEntry() {
      // Get assignments from inputs
      const assignments = getCardAssignments();

      cardRows = Array.from({ length: TOTAL_CARDS }, (_, i) => {
        const cId = i + 1;
        const assign = assignments[cId];
        return {
          cardNo: cId,
          product: assign ? assign.productName : PRODUCT_DEFAULT,
          coilers: Array(COILERS_PER_CARD).fill(null),
          avg: null
        };
      });

      // Reset unsaved data flag when starting new entry
      hasUnsavedData = false;

      const tbody = document.querySelector('#sliverTable tbody');
      tbody.innerHTML = '';

      for (let i = 0; i < TOTAL_CARDS; i++) {
        const cardNo = i + 1;
        const tr = document.createElement('tr');
        tr.id = `cardRow_${cardNo}`;

        const assign = assignments[cardNo];
        const assignedProduct = assign ? assign.productName : '';

        // Set row color if assigned
        let rowClass = '';
        if (assignedProduct) {
          rowClass = 'row-' + getProductColorClass(assignedProduct);
          tr.className = rowClass;
        }

        // Build options with selected
        const optionsHtml = getProductOptions().map(p => {
          const selected = (p === assignedProduct) ? 'selected' : '';
          return `<option value="${escapeHtml(p)}" ${selected}>${escapeHtml(p)}</option>`;
        }).join('');

        const defaultSelected = assignedProduct ? '' : 'selected';

        // Target display
        let targetDisplay = '-';
        let targetStyle = 'font-weight: 600; color: #2c3e50;';
        if (assign && assign.target) {
          const tVal = parseFloat(assign.target);
          if (isFinite(tVal) && tVal > 0) {
            targetDisplay = tVal.toFixed(2);
          } else {
            targetDisplay = '-';
            targetStyle = 'color: #999;';
          }
        } else {
          targetStyle = 'color: #999;';
        }

        tr.innerHTML = `
        <td><strong>${cardNo}</strong></td>
        <td>
          <select class="card-input" style="padding:8px 10px; font-size:14px;"
            onchange="updateProduct(${cardNo}, this.value)">
            <option value="" ${defaultSelected}>-- Select --</option>
            ${optionsHtml}
          </select>
        </td>
        <td id="targetCell_${cardNo}" style="${targetStyle}">${targetDisplay}</td>
        ${Array.from({ length: COILERS_PER_CARD }, (_, c) => `
          <td><input type="number" step="0.001" style="width:120px;" id="coiler_${cardNo}_${c + 1}"
              onchange="updateCoiler(${cardNo}, ${c + 1}, this.value)"
              onfocus="handleCoilerFocus(${cardNo}, ${c + 1})"></td>
        `).join('')}
        <td class="avg-cell" id="avgCell_${cardNo}">-</td>
        <td id="minCell_${cardNo}">-</td>
        <td id="maxCell_${cardNo}">-</td>
      `;
        tbody.appendChild(tr);
      }

      document.getElementById('testSection').style.display = 'block';

      // Show Save button but disabled initially (Print Current only shown after saving)
      document.getElementById('saveBtn').style.display = 'inline-block';
      document.getElementById('printCurrentBtn').style.display = 'none';
      disableSavePrintButtons();

      document.getElementById('metrics').style.display = 'none';

      destroyChartMap(chartInstances, 'chartsGrid');
      currentTest = null;
      isDataCalculated = false;
      isTestSaved = false;

      // Check for scale support - show message if not available
      if (!navigator.serial) {
        showScaleStatus('Web Serial API not supported. Please enter values manually.', 'info');
      }
    }

    function updateProduct(cardNo, product) {
      cardRows[cardNo - 1].product = product;
      const tr = document.getElementById(`cardRow_${cardNo}`);

      // Remove all product color classes
      if (tr) {
        tr.classList.remove('row-qtip', 'row-triple', 'row-organic', 'row-special', 'row-custom');
        // Add appropriate color class based on product
        if (product) {
          const colorClass = getProductColorClass(product);
          tr.classList.add(`row-${colorClass}`);
        }
      }

      // Update target value display
      const targets = getTargets();
      const targetCell = document.getElementById(`targetCell_${cardNo}`);
      if (targetCell) {
        if (product && targets[product] !== null && targets[product] > 0) {
          targetCell.textContent = targets[product].toFixed(2);
          targetCell.style.color = '#2c3e50';
        } else {
          targetCell.textContent = '-';
          targetCell.style.color = '#999';
        }
      }

      // If data was previously calculated, disable buttons (need to recalculate)
      if (isDataCalculated) {
        isDataCalculated = false;
        disableSavePrintButtons();
        // If test was saved, show Save button again (but disabled)
        if (isTestSaved) {
          document.getElementById('saveBtn').style.display = 'inline-block';
          document.getElementById('printCurrentBtn').style.display = 'inline-block';
        }
      }
    }

    function updateCoiler(cardNo, coilerNo, value) {
      const row = cardRows[cardNo - 1];
      const v = (value === '' || value === null) ? null : parseFloat(value);
      row.coilers[coilerNo - 1] = isFinite(v) ? v : null;

      const vals = row.coilers.filter(x => x !== null);
      row.avg = vals.length ? (vals.reduce((a, b) => a + b, 0) / vals.length) : null;

      // Calculate min and max
      const minVal = vals.length > 0 ? Math.min(...vals) : null;
      const maxVal = vals.length > 0 ? Math.max(...vals) : null;

      // Update display
      document.getElementById(`avgCell_${cardNo}`).textContent = row.avg === null ? '-' : row.avg.toFixed(2);
      document.getElementById(`minCell_${cardNo}`).textContent = minVal === null ? '-' : minVal.toFixed(3);
      document.getElementById(`maxCell_${cardNo}`).textContent = maxVal === null ? '-' : maxVal.toFixed(3);

      // Mark as having unsaved data if any value is entered
      // Also check if all data has been cleared
      const hasAnyData = cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));
      hasUnsavedData = hasAnyData;

      // If data was previously calculated, disable buttons (need to recalculate)
      if (isDataCalculated) {
        isDataCalculated = false;
        disableSavePrintButtons();
        // If test was saved, show Save button again (but disabled)
        if (isTestSaved) {
          document.getElementById('saveBtn').style.display = 'inline-block';
          document.getElementById('printCurrentBtn').style.display = 'inline-block';
        }
      }

      // Auto-update charts if there's data
      autoUpdateCharts();
    }

    // Enable Save and Print buttons
    function enableSavePrintButtons() {
      const saveBtn = document.getElementById('saveBtn');
      const printBtn = document.getElementById('printCurrentBtn');
      if (saveBtn) {
        saveBtn.disabled = false;
      }
      if (printBtn) {
        printBtn.disabled = false;
      }
    }

    // Disable Save and Print buttons (light color, not enabled)
    function disableSavePrintButtons() {
      const saveBtn = document.getElementById('saveBtn');
      const printBtn = document.getElementById('printCurrentBtn');
      if (saveBtn) {
        saveBtn.disabled = true;
      }
      if (printBtn) {
        printBtn.disabled = true;
      }
    }

    // Auto-update charts incrementally as data is entered
    function autoUpdateCharts() {
      try {
        const anyValues = cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));
        if (!anyValues) {
          // Hide metrics if no data
          const metricsContainer = document.getElementById('metrics');
          if (metricsContainer) metricsContainer.style.display = 'none';
          return;
        }

        const targets = getTargets();
        const acceptableRanges = getAcceptableRanges();
        const groups = groupData(cardRows);
        const productsPresent = Object.keys(groups)
          .filter(p => groups[p].allValues.length > 0)
          .sort((a, b) => a.localeCompare(b));

        if (!productsPresent.length) {
          // Hide metrics if no product groups
          const metricsContainer = document.getElementById('metrics');
          if (metricsContainer) metricsContainer.style.display = 'none';
          return;
        }

        // Update charts (without full validation - allows incremental updates)
        renderGroupedCharts(groups, productsPresent, 'chartsGrid', chartInstances, targets, acceptableRanges);

        // Update metrics (without full validation - allows incremental updates)
        autoUpdateMetrics(groups, productsPresent, targets, acceptableRanges);
      } catch (e) {
        // Silently fail on auto-update - don't interrupt user input
        console.error('Auto-update charts error:', e);
      }
    }

    // Auto-update metrics incrementally as data is entered
    function autoUpdateMetrics(groups, productsPresent, targets, acceptableRanges) {
      try {
        const metricsContainer = document.getElementById('metrics');
        if (!metricsContainer) return;

        // Clear row highlighting
        for (const r of cardRows) {
          const tr = document.getElementById(`cardRow_${r.cardNo}`);
          if (tr) tr.classList.remove('out-of-control');
        }

        let oocCardsAll = 0;
        let oocCoilersAll = 0;
        const productStats = {};

        // OOC computations are per product, using per-product ranges
        for (const p of productsPresent) {
          const g = groups[p];
          const productRange = acceptableRanges[p] || 5.0;

          // Chart-level stats (mean-based)
          const meanCard = meanOf(g.cardAvgs);
          const limCardMean = limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(g.allValues);
          const limAllMean = limitsFromMean(meanAll, productRange);

          // OOC limits (target-based when available, otherwise mean-based)
          const tgt = targets[p];
          const limTarget = (tgt !== null && isFinite(tgt) && tgt > 0) ? limitsFromTarget(tgt, productRange) : null;
          const limCardOOC = limTarget || limCardMean;
          const limCoilerOOC = limTarget || limAllMean;

          let oocCards = 0;
          let oocCoilers = 0;

          for (const r of cardRows) {
            if ((r.product || '').trim() !== p) continue;

            // Card average OOC
            if (r.avg !== null && isFinite(r.avg)) {
              if (!withinLimits(Number(r.avg), limCardOOC)) {
                oocCards++;
                oocCardsAll++;
                const tr = document.getElementById(`cardRow_${r.cardNo}`);
                if (tr) tr.classList.add('out-of-control');
              }
            }

            // Individual coilers OOC
            for (const v of (r.coilers || [])) {
              if (v === null || !isFinite(v)) continue;
              if (!withinLimits(Number(v), limCoilerOOC)) {
                oocCoilers++;
                oocCoilersAll++;
              }
            }
          }

          // Calculate min/max for card averages and coiler readings
          const cardAvgMin = g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs) : null;
          const cardAvgMax = g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs) : null;
          const coilerMin = g.allValues.length > 0 ? Math.min(...g.allValues) : null;
          const coilerMax = g.allValues.length > 0 ? Math.max(...g.allValues) : null;

          productStats[p] = {
            countCards: g.cardAvgs.length,
            countCoilerValues: g.allValues.length,
            cardAvgMean: meanCard,
            cardAvgLCL: limCardMean.lcl,
            cardAvgUCL: limCardMean.ucl,
            cardAvgMin,
            cardAvgMax,
            allMean: meanAll,
            allLCL: limAllMean.lcl,
            allUCL: limAllMean.ucl,
            coilerMin,
            coilerMax,
            target: tgt,
            targetLCL: limCardOOC.lcl,
            targetUCL: limCardOOC.ucl,
            oocCards,
            oocCoilers
          };
        }

        // Build metrics HTML: first box for products, then per-product boxes
        let metricsHTML = `
        <div class="metric">
          <div class="label">Products Detected</div>
          <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
        </div>
      `;

        // Calculate total cards and coilers per product
        const totalCardsPerProduct = {};
        const totalCoilersPerProduct = {};
        for (const p of productsPresent) {
          totalCardsPerProduct[p] = groups[p].cardAvgs.length;
          totalCoilersPerProduct[p] = groups[p].allValues.length;
        }

        // Add per-product metrics (2 boxes per product: cards and coilers)
        for (const p of productsPresent) {
          const productRange = acceptableRanges[p] || 5.0;
          const rangeStr = productRange.toFixed(1);
          const totalCards = totalCardsPerProduct[p];
          const totalCoilers = totalCoilersPerProduct[p];
          const oocCards = productStats[p].oocCards || 0;
          const oocCoilers = productStats[p].oocCoilers || 0;
          const cardsBg = oocCards > 0 ? '#e74c3c' : '#3498db';
          const coilersBg = oocCoilers > 0 ? '#e74c3c' : '#3498db';

          const cardMin = productStats[p].cardAvgMin !== null ? productStats[p].cardAvgMin.toFixed(2) : '-';
          const cardMax = productStats[p].cardAvgMax !== null ? productStats[p].cardAvgMax.toFixed(2) : '-';
          const coilerMinVal = productStats[p].coilerMin !== null ? productStats[p].coilerMin.toFixed(3) : '-';
          const coilerMaxVal = productStats[p].coilerMax !== null ? productStats[p].coilerMax.toFixed(3) : '-';

          metricsHTML += `
          <div class="metric" style="background: ${cardsBg};">
            <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCards} out of ${totalCards}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
          </div>
          <div class="metric" style="background: ${coilersBg};">
            <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCoilers} out of ${totalCoilers}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${coilerMinVal} | Max: ${coilerMaxVal}</div>
          </div>
        `;
        }

        metricsContainer.innerHTML = metricsHTML;
        metricsContainer.style.display = 'flex';
      } catch (e) {
        // Silently fail on auto-update - don't interrupt user input
        console.error('Auto-update metrics error:', e);
      }
    }

    function simulateData() {
      // Get existing target values (infeed values) or use defaults
      const targets = getTargets();
      const defaultBase = 4.6;

      const inputs = document.querySelectorAll('#sliverTable tbody input[type="number"]');

      // Iterate through existing card rows set up by startEntry
      for (let i = 0; i < TOTAL_CARDS; i++) {
        const row = cardRows[i];
        const product = row.product; // Already set by startEntry based on assignments

        // If no product assigned to this card, skip
        if (!product) continue;

        // Get target for this product
        const tVal = targets[product];
        const targetValue = (tVal !== null && isFinite(tVal) && tVal > 0) ? tVal : defaultBase;

        // Simulate values
        const base = targetValue;
        const cardBias = (Math.random() - 0.5) * (base * 0.03);

        for (let c = 0; c < COILERS_PER_CARD; c++) {
          const v = base + cardBias + (Math.random() - 0.5) * (base * 0.02);
          updateCoiler(i + 1, c + 1, v.toFixed(3));

          // Update input field if it exists
          if (inputs[i * COILERS_PER_CARD + c]) {
            inputs[i * COILERS_PER_CARD + c].value = v.toFixed(3);
          }
        }
      }
    }

    // -----------------------------
    // Math helpers
    // -----------------------------
    function meanOf(arr) { return arr.reduce((a, b) => a + b, 0) / arr.length; }
    function sampleStd(arr, mean) {
      if (arr.length < 2) return 0;
      const v = arr.reduce((s, x) => s + (x - mean) ** 2, 0) / (arr.length - 1);
      return Math.sqrt(v);
    }
    function limitsFromMean(mean, rangePct) {
      const range = rangePct !== undefined ? rangePct : getAcceptableRange();
      const factor = range / 100;
      return { lcl: mean * (1 - factor), ucl: mean * (1 + factor) };
    }
    function limitsFromTarget(target, rangePct) {
      const range = rangePct !== undefined ? rangePct : getAcceptableRange();
      const factor = range / 100;
      return { lcl: target * (1 - factor), ucl: target * (1 + factor) };
    }
    function withinLimits(v, lim) { return v >= lim.lcl && v <= lim.ucl; }

    function groupData(rows) {
      if (!rows) return {};
      const groups = {};

      const parseLocal = (v) => {
        if (v === null || v === undefined || v === '-') return NaN;
        const s = String(v).replace(/[^\d.-]/g, '');
        return s ? parseFloat(s) : NaN;
      };

      for (const r of rows) {
        const p = (r.product || '').trim();
        if (!p) continue;
        if (!groups[p]) groups[p] = { cardAvgs: [], allValues: [], cardNos: [] };

        const avgVal = parseLocal(r.avg !== undefined ? r.avg : r.count);
        if (!isNaN(avgVal)) {
          groups[p].cardAvgs.push(avgVal);
          groups[p].cardNos.push(r.cardNo || r.sample || '?');
          // If no coilers, count as single value
          if (!(r.coilers || []).length) {
            groups[p].allValues.push(avgVal);
          }
        }

        for (const v of (r.coilers || [])) {
          const cv = parseLocal(v);
          if (!isNaN(cv)) groups[p].allValues.push(cv);
        }
      }
      return groups;
    }

    // -----------------------------
    // Validation rules
    // -----------------------------
    function validatePerCardRulesOrAlert(rows) {
      const missingProductCards = [];
      const partialCoilerCards = [];

      for (const r of rows) {
        const enteredCount = (r.coilers || []).filter(v => v !== null && isFinite(v)).length;
        if (enteredCount === 0) continue;

        if (!(r.product || '').trim()) missingProductCards.push(r.cardNo);
        if (enteredCount !== COILERS_PER_CARD) partialCoilerCards.push(r.cardNo);
      }

      if (missingProductCards.length || partialCoilerCards.length) {
        let msg = '';
        if (missingProductCards.length) msg += `Please select Product for Card(s): ${missingProductCards.join(', ')}.\n`;
        if (partialCoilerCards.length) msg += `Please enter all 4 coiler values for Card(s): ${partialCoilerCards.join(', ')}.\n`;
        alert(msg.trim());
        return false;
      }
      return true;
    }

    // Require target for any product that has at least one entered card (so OOC can be target-based)
    function validateTargetsForUsedProductsOrAlert(rows, targets) {
      const usedProducts = new Set();
      for (const r of rows) {
        const enteredCount = (r.coilers || []).filter(v => v !== null && isFinite(v)).length;
        if (enteredCount > 0) usedProducts.add((r.product || '').trim());
      }

      const missingTargets = [];
      for (const p of usedProducts) {
        if (!p) continue;
        if (!(targets[p] !== null && isFinite(targets[p]) && targets[p] > 0)) {
          missingTargets.push(p);
        }
      }

      if (missingTargets.length) {
        alert(`Please enter Target (g/m) for product(s): ${missingTargets.join(', ')}.\nTargets are required for Out-of-Control checks.`);
        return false;
      }
      return true;
    }

    // -----------------------------
    // Charting (Histogram + Normal curve + Mean/LCL/UCL + Target line)
    // -----------------------------
    function buildHistogram(data) {
      const n = data.length;
      if (n === 0) return { centers: [], counts: [], min: 0, max: 0, binSize: 1 };
      const bins = Math.min(14, Math.max(6, Math.round(Math.sqrt(n) * 1.8)));
      const min = Math.min(...data);
      const max = Math.max(...data);
      const range = (max - min) || 1;
      const binSize = range / bins;

      const counts = new Array(bins).fill(0);
      for (const v of data) {
        const idx = Math.min(Math.floor((v - min) / binSize), bins - 1);
        counts[idx]++;
      }

      const centers = counts.map((_, i) => min + (i + 0.5) * binSize);
      return { centers, counts, min, max, binSize };
    }

    function buildNormalCurvePoints(min, max, mean, sigma, nPoints, scale) {
      const xs = Array.from({ length: nPoints }, (_, i) => min + i * (max - min) / (nPoints - 1));
      return xs.map(x => {
        const z = (x - mean) / sigma;
        const pdf = Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI);
        return { x, y: pdf * scale };
      });
    }

    function plotDistribution(canvasId, data, mean, lcl, ucl, titleText, chartMap, targetValueOrNull) {
      if (!data || data.length === 0) return;
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');

      // Detect if this is a print chart
      const isPrint = canvasId && canvasId.startsWith('print_');

      const { centers, counts, min, max, binSize } = buildHistogram(data);
      const sigma = sampleStd(data, mean) || 1e-9;
      const scale = data.length * binSize;
      const curve = buildNormalCurvePoints(min, max, mean, sigma, 160, scale);

      const bars = centers.map((x, i) => ({ x, y: counts[i] }));

      const lines = [];
      if (!isNaN(mean)) lines.push({ value: mean, color: '#111827', dash: [], label: `Mean: ${mean.toFixed(3)}`, labelBg: '#111827' });
      if (!isNaN(lcl)) lines.push({ value: lcl, color: '#ef4444', dash: [], label: `LCL: ${lcl.toFixed(3)}`, labelBg: '#ef4444' });
      if (!isNaN(ucl)) lines.push({ value: ucl, color: '#ef4444', dash: [], label: `UCL: ${ucl.toFixed(3)}`, labelBg: '#ef4444' });

      if (targetValueOrNull !== null && isFinite(targetValueOrNull)) {
        lines.push({ value: targetValueOrNull, color: '#16a34a', dash: [], label: `Target: ${Number(targetValueOrNull).toFixed(2)}`, labelBg: '#16a34a' });
      }

      // Font sizes - increase for print to ensure readability (browser renders smaller in print)
      const titleFontSize = isPrint ? 17 : 14;
      const axisFontSize = isPrint ? 15 : 12;
      const legendFontSize = isPrint ? 14 : 12;
      const printFontFamily = 'Arial, sans-serif';

      const chart = new Chart(ctx, {
        type: 'bar',
        data: {
          datasets: [
            {
              type: 'bar',
              label: 'Histogram',
              data: bars,
              parsing: false,
              backgroundColor: 'rgba(54, 162, 235, 0.60)',
              borderColor: 'rgba(54, 162, 235, 0.90)',
              borderWidth: isPrint ? 2 : 1,
              barThickness: 'flex'
            },
            {
              type: 'line',
              label: 'Normal Curve',
              data: curve,
              parsing: false,
              borderColor: '#e74c3c',
              borderWidth: isPrint ? 3 : 2,
              tension: 0.35,
              pointRadius: 0
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: titleText,
              font: { size: titleFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
            },
            legend: {
              display: true,
              labels: {
                font: { size: legendFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined },
                boxWidth: isPrint ? 20 : 12,
                padding: isPrint ? 12 : 8
              }
            },
            limitLinesPlugin: { lines }
          },
          scales: {
            x: {
              type: 'linear',
              // Ensure LCL and UCL are always visible by extending axis range
              min: (!isNaN(lcl) && !isNaN(ucl)) ? Math.min(min, lcl - (ucl - lcl) * 0.1) : min,
              max: (!isNaN(lcl) && !isNaN(ucl)) ? Math.max(max, ucl + (ucl - lcl) * 0.1) : max,
              title: {
                display: true,
                text: 'Yarn Count (Ne)',  // Fixed label for Count & Strength module
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              },
              ticks: {
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Frequency',
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              },
              ticks: {
                font: { size: axisFontSize, weight: 'bold', family: isPrint ? printFontFamily : undefined }
              }
            }
          }
        }
      });

      chartMap.set(canvasId, chart);
    }

    function renderGroupedCharts(groups, productsPresent, containerId, chartMap, targets, rangePctOrRanges) {
      destroyChartMap(chartMap, containerId);
      const container = document.getElementById(containerId);

      // Support both old format (single range) and new format (per-product ranges object)
      const ranges = typeof rangePctOrRanges === 'object' && rangePctOrRanges !== null && !isFinite(rangePctOrRanges)
        ? rangePctOrRanges
        : null;
      const defaultRange = typeof rangePctOrRanges === 'number' ? rangePctOrRanges : 5.0;

      for (const p of productsPresent) {
        const g = groups[p];
        if (!g || g.allValues.length === 0) continue;

        const target = (targets && targets[p] !== undefined) ? targets[p] : null;
        const productRange = ranges && ranges[p] !== undefined ? ranges[p] : defaultRange;

        // Card averages chart
        {
          const id = `${containerId}_cardavg_${safeId(p)}`;
          container.appendChild(makeChartCard(`${p} — Distribution (Card Averages)`, id));
          const mean = meanOf(g.cardAvgs);
          const { lcl, ucl } = limitsFromMean(mean, productRange);
          plotDistribution(id, g.cardAvgs, mean, lcl, ucl, `Product: ${p} (Card Averages)`, chartMap, target);
        }

        // All coilers chart
        {
          const id = `${containerId}_all_${safeId(p)}`;
          container.appendChild(makeChartCard(`${p} — Distribution (All Coiler Readings)`, id));
          const mean = meanOf(g.allValues);
          const { lcl, ucl } = limitsFromMean(mean, productRange);
          plotDistribution(id, g.allValues, mean, lcl, ucl, `Product: ${p} (All Coiler Readings)`, chartMap, target);
        }
      }
    }

    function makeChartCard(title, canvasId) {
      const wrap = document.createElement('div');
      wrap.className = 'chart-card';
      const h = document.createElement('h3');
      h.textContent = title;
      wrap.appendChild(h);
      const canvas = document.createElement('canvas');
      canvas.id = canvasId;
      wrap.appendChild(canvas);
      return wrap;
    }

    function destroyChartMap(chartMap, containerId) {
      for (const ch of chartMap.values()) ch.destroy();
      chartMap.clear();
      const container = document.getElementById(containerId);
      if (container) container.innerHTML = '';
    }

    // -----------------------------
    // Calculate (OOC checks use Target ±5%)
    // -----------------------------
    function calculateResults_old() {
      try {
        const anyValues = cardRows.some(r => (r.coilers || []).some(v => v !== null && isFinite(v)));
        if (!anyValues) { alert('Please enter coiler weights (at least one value).'); return; }

        if (!validatePerCardRulesOrAlert(cardRows)) return;

        const targets = getTargets();
        if (!validateTargetsForUsedProductsOrAlert(cardRows, targets)) return;

        const acceptableRanges = getAcceptableRanges();
        const groups = groupData(cardRows);
        const productsPresent = Object.keys(groups)
          .filter(p => groups[p].allValues.length > 0)
          .sort((a, b) => a.localeCompare(b));

        if (!productsPresent.length) { alert('No valid product groups found.'); return; }

        // Clear row highlighting
        for (const r of cardRows) {
          const tr = document.getElementById(`cardRow_${r.cardNo}`);
          if (tr) tr.classList.remove('out-of-control');
        }

        let oocCardsAll = 0;
        let oocCoilersAll = 0;

        const summaryByProduct = {};
        const productStats = {};
        const outOfControlCardNos = [];

        // OOC computations are per product, using per-product ranges
        for (const p of productsPresent) {
          const g = groups[p];
          const productRange = acceptableRanges[p] || 5.0;

          // Chart-level stats (mean-based)
          const meanCard = meanOf(g.cardAvgs);
          const limCardMean = limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(g.allValues);
          const limAllMean = limitsFromMean(meanAll, productRange);

          // OOC limits (target-based when available; targets are required by validation for used products)
          const tgt = targets[p];
          const limTarget = (tgt !== null && isFinite(tgt)) ? limitsFromTarget(tgt, productRange) : null;
          const limCardOOC = limTarget || limCardMean;
          const limCoilerOOC = limTarget || limAllMean;

          let oocCards = 0;
          let oocCoilers = 0;

          for (const r of cardRows) {
            if ((r.product || '').trim() !== p) continue;

            // Card average OOC
            if (r.avg !== null && isFinite(r.avg)) {
              if (!withinLimits(Number(r.avg), limCardOOC)) {
                oocCards++;
                oocCardsAll++;
                outOfControlCardNos.push(r.cardNo);
                const tr = document.getElementById(`cardRow_${r.cardNo}`);
                if (tr) tr.classList.add('out-of-control');
              }
            }

            // Individual coilers OOC
            for (const v of (r.coilers || [])) {
              if (v === null || !isFinite(v)) continue;
              if (!withinLimits(Number(v), limCoilerOOC)) {
                oocCoilers++;
                oocCoilersAll++;
              }
            }
          }

          summaryByProduct[p] = { cards: g.cardAvgs.length, meanCardAvg: meanCard };

          // Calculate min/max for card averages and coiler readings
          const cardAvgMin = g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs) : null;
          const cardAvgMax = g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs) : null;
          const coilerMin = g.allValues.length > 0 ? Math.min(...g.allValues) : null;
          const coilerMax = g.allValues.length > 0 ? Math.max(...g.allValues) : null;

          productStats[p] = {
            countCards: g.cardAvgs.length,
            countCoilerValues: g.allValues.length,

            // Chart stats (mean-based)
            cardAvgMean: meanCard,
            cardAvgLCL: limCardMean.lcl,
            cardAvgUCL: limCardMean.ucl,
            cardAvgMin,
            cardAvgMax,

            allMean: meanAll,
            allLCL: limAllMean.lcl,
            allUCL: limAllMean.ucl,
            coilerMin,
            coilerMax,

            // OOC stats (target-based)
            target: tgt,
            targetLCL: limCardOOC.lcl,
            targetUCL: limCardOOC.ucl,
            oocCards,
            oocCoilers
          };
        }

        // Build metrics HTML: first box for products, then per-product boxes
        const metricsContainer = document.getElementById('metrics');
        let metricsHTML = `
        <div class="metric">
          <div class="label">Products Detected</div>
          <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
        </div>
      `;

        // Calculate total cards and coilers per product
        const totalCardsPerProduct = {};
        const totalCoilersPerProduct = {};
        for (const p of productsPresent) {
          totalCardsPerProduct[p] = groups[p].cardAvgs.length;
          totalCoilersPerProduct[p] = groups[p].allValues.length;
        }

        // Add per-product metrics (2 boxes per product: cards and coilers)
        for (const p of productsPresent) {
          const productRange = acceptableRanges[p] || 5.0;
          const rangeStr = productRange.toFixed(1);
          const totalCards = totalCardsPerProduct[p];
          const totalCoilers = totalCoilersPerProduct[p];
          const oocCards = productStats[p].oocCards || 0;
          const oocCoilers = productStats[p].oocCoilers || 0;
          const cardsBg = oocCards > 0 ? '#e74c3c' : '#3498db';
          const coilersBg = oocCoilers > 0 ? '#e74c3c' : '#3498db';

          const cardMin = productStats[p].cardAvgMin !== null ? productStats[p].cardAvgMin.toFixed(2) : '-';
          const cardMax = productStats[p].cardAvgMax !== null ? productStats[p].cardAvgMax.toFixed(2) : '-';
          const coilerMinVal = productStats[p].coilerMin !== null ? productStats[p].coilerMin.toFixed(3) : '-';
          const coilerMaxVal = productStats[p].coilerMax !== null ? productStats[p].coilerMax.toFixed(3) : '-';

          metricsHTML += `
          <div class="metric" style="background: ${cardsBg};">
            <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCards} out of ${totalCards}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
          </div>
          <div class="metric" style="background: ${coilersBg};">
            <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
            <div class="value">${oocCoilers} out of ${totalCoilers}</div>
            <div class="value" style="font-size: 12px; margin-top: 4px; opacity: 0.9;">Min: ${coilerMinVal} | Max: ${coilerMaxVal}</div>
          </div>
        `;
        }

        metricsContainer.innerHTML = metricsHTML;
        metricsContainer.style.display = 'flex';

        // Store out-of-control card numbers for warning
        // (Already populated in the loop above: outOfControlCardNos)

        currentTest = {
          reportNumber: document.getElementById('reportNumber').value,
          operatorName: document.getElementById('operatorName').value.trim(),
          testDate: document.getElementById('testDate').value,
          dateTime: new Date().toLocaleString(),
          productsPresent,
          targets,
          acceptableRanges,
          productStats,
          summaryByProduct,
          cardRows: JSON.parse(JSON.stringify(cardRows)),
          oocCardsAll,
          oocCoilersAll,
          outOfControlCardNos
        };

        // Charts grouped by product (mean-based limits shown; target line also shown)
        renderGroupedCharts(groups, productsPresent, 'chartsGrid', chartInstances, targets, acceptableRanges);

        // Show and enable buttons after calculation
        document.getElementById('saveBtn').style.display = 'inline-block';
        document.getElementById('printCurrentBtn').style.display = 'none'; // Print Current button is only shown after saving
        enableSavePrintButtons();
        isDataCalculated = true;
      } catch (e) {
        showError("Calculate failed: " + (e && e.message ? e.message : String(e)));
        console.error(e);
      }
    }

    // -----------------------------
    // Saved Tests Display / Load / Delete / Details
    // (saveTest removed - using main version with versioning logic)
    // -----------------------------






    // -----------------------------
    // Filtering & Sorting functionality
    // -----------------------------

    let currentSort = { column: 'dateTime', direction: 'desc' };
    let filteredTests = [];

    function onSrchDateRangeChange() {
      const type = document.getElementById('srchDateRange').value;
      document.getElementById('srchCustomDates').style.display = type === 'custom' ? 'flex' : 'none';
    }

    function clearSrchFilters() {
      document.getElementById('srchDateRange').value = 'all';
      document.getElementById('srchDateFrom').value = '';
      document.getElementById('srchDateTo').value = '';
      document.getElementById('srchMachine').value = '';
      document.getElementById('srchLot').value = '';
      document.getElementById('srchProduct').value = '';
      document.getElementById('srchProcess').value = '';
      onSrchDateRangeChange();
      applySrchFilters();
    }

    function populateSrchDropdowns() {
      const saved = getSavedTests();
      const fields = {
        srchMachine: 'machine',
        srchLot: 'lotNumber',
        srchProduct: 'product',
        srchProcess: 'process'
      };

      for (const [id, field] of Object.entries(fields)) {
        const el = document.getElementById(id);
        if (!el) continue;
        const current = el.value;
        const uniques = [...new Set(saved.map(t => t[field] || t.metrics?.[field]).filter(Boolean))].sort();
        el.innerHTML = '<option value="">All</option>' +
          uniques.map(u => `<option value="${u}">${u}</option>`).join('');
        if (uniques.includes(current)) el.value = current;
      }
    }

    function applySrchFilters() {
      const saved = getSavedTests();
      const dateType = document.getElementById('srchDateRange').value;
      const machine = document.getElementById('srchMachine').value;
      const lot = document.getElementById('srchLot').value;
      const product = document.getElementById('srchProduct').value;
      const process = document.getElementById('srchProcess').value;

      filteredTests = saved.filter(test => {
        // Date Logic
        if (dateType !== 'all') {
          let dateFrom, dateTo;
          if (dateType === 'custom') {
            const from = document.getElementById('srchDateFrom').value;
            const to = document.getElementById('srchDateTo').value;
            if (from) dateFrom = new Date(from + 'T00:00:00');
            if (to) dateTo = new Date(to + 'T23:59:59');
          } else {
            const range = getDateRange(dateType);
            if (range) { dateFrom = range.from; dateTo = range.to; dateTo.setHours(23, 59, 59); }
          }
          const tDate = new Date((test.dateTime || test.testDate || '').split(',')[0]);
          if (dateFrom && tDate < dateFrom) return false;
          if (dateTo && tDate > dateTo) return false;
        }

        // Field Logic
        const tMachine = test.machine || test.machineId || '-';
        const tLot = test.lotNumber || '-';
        const tProd = test.product || '-';
        const tProc = test.process || '-';

        if (machine && tMachine !== machine) return false;
        if (lot && tLot !== lot) return false;
        if (product && tProd !== product) return false;
        if (process && tProc !== process) return false;

        return true;
      });

      renderSavedTests();
    }

    function sortSavedTests(column) {
      if (currentSort.column === column) {
        currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
      } else {
        currentSort.column = column;
        currentSort.direction = 'asc';
      }
      renderSavedTests();
    }

    function updateSortIcons() {
      const cols = ['dateTime', 'reportNumber', 'machine', 'product', 'process', 'lotNumber', 'sampleCount'];
      cols.forEach(c => {
        const el = document.getElementById(`sort-${c}`);
        if (!el) return;
        if (currentSort.column === c) {
          el.innerHTML = currentSort.direction === 'asc' ? ' ▲' : ' ▼';
          el.style.color = '#3498db';
        } else {
          el.innerHTML = '';
        }
      });
    }

    function renderSavedTests() {
      const saved = getSavedTests();
      const list = document.getElementById('savedList');
      if (!list) return;

      // Populate dropdowns only if not already filtered to avoid feedback loop
      populateSrchDropdowns();

      let displayData = [...(filteredTests.length > 0 ? filteredTests : saved)];

      // Sorting Logic
      displayData.sort((a, b) => {
        let valA = a[currentSort.column] || (a.metrics ? a.metrics[currentSort.column] : '') || '';
        let valB = b[currentSort.column] || (b.metrics ? b.metrics[currentSort.column] : '') || '';

        // Special handling for reportNumber or date
        if (currentSort.column === 'dateTime') {
          const dateA = new Date(valA);
          const dateB = new Date(valB);
          if (!isNaN(dateA) && !isNaN(dateB)) {
            return currentSort.direction === 'asc' ? dateA - dateB : dateB - dateA;
          }
        }

        if (isFinite(valA) && isFinite(valB)) {
          return currentSort.direction === 'asc' ? valA - valB : valB - valA;
        }

        return currentSort.direction === 'asc'
          ? String(valA).localeCompare(String(valB))
          : String(valB).localeCompare(String(valA));
      });

      list.innerHTML = '';
      updateSortIcons();

      displayData.forEach((test, idx) => {
        const originalIndex = saved.indexOf(test);
        const tr = document.createElement('tr');
        tr.id = 'report-row-' + originalIndex;
        tr.setAttribute('data-lot', test.lotNumber || 'Unknown');
        tr.setAttribute('data-original-index', originalIndex);

        if (test.testType === 'Count & Strength') {
          tr.innerHTML = `
            <td><input type="checkbox" onchange="onSavedSelectionChanged(this)"></td>
            <td>${escapeHtml(test.dateTime || 'N/A')}</td>
            <td>${escapeHtml(test.reportNumber || 'N/A')}</td>
            <td>${escapeHtml(test.machine || test.machineId || 'N/A')}</td>
            <td>${escapeHtml(test.product || 'N/A')}</td>
            <td>${escapeHtml(test.process || 'N/A')}</td>
            <td>${escapeHtml(test.lotNumber || 'N/A')}</td>
            <td>${escapeHtml(test.yarnCount || test.targetCount || '-')}</td>
            <td>${escapeHtml(test.avgCount || test.metrics?.avgCount || '-')}</td>
            <td>${escapeHtml(test.countCV || test.metrics?.countCV || '-')}</td>
            <td>${escapeHtml(test.avgStrength || test.metrics?.avgStrength || '-')}</td>
            <td>${escapeHtml(test.avgCSP || test.metrics?.avgCSP || '-')}</td>
            <td>${escapeHtml(test.outOfLimitCount || '0.0')}%</td>
            <td><strong>${(test.rows || []).length}</strong></td>
            <td><button class="btn-muted" style="margin:0; padding:8px 12px;" onclick="viewDetailsByRow(event, ${originalIndex})">View Details</button></td>
          `;
        } else {
          // Sliver fallback or legacy sliver
          const summary = formatProductSummary(test.summaryByProduct);
          const targetsText = (typeof formatTargets === 'function') ? formatTargets(test.targets) : (test.yarnCount || test.targetCount || '-');
          const sliverSamples = test.cardRows ? test.cardRows.length : (test.samples ? (test.samples.length || 0) : 0);

          tr.innerHTML = `
            <td><input type="checkbox" onchange="onSavedSelectionChanged(this)"></td>
            <td>${escapeHtml(test.dateTime || 'N/A')}</td>
            <td>${escapeHtml(test.reportNumber || 'N/A')}</td>
            <td colspan="4" style="text-align:left; font-size:11px; color:#666;">Sliver/Carding: ${escapeHtml(summary)}</td>
            <td>${escapeHtml(targetsText)}</td>
            <td colspan="5">-</td>
            <td><strong>${sliverSamples}</strong></td>
            <td><button class="btn-muted" style="margin:0; padding:8px 12px;" onclick="viewDetailsByRow(event, ${originalIndex})">View Details</button></td>
          `;
        }
        list.appendChild(tr);
      });

      // Update selection UI
      onSavedSelectionChanged();
    }

    function closeFilteredResults() {
      document.getElementById('filteredResultsPanel').style.display = 'none';
      destroyChartMap(filteredChartInstances, 'filteredChartsGrid');
    }

    function printFilteredResults() {
      if (filteredTests.length === 0) {
        alert('No filtered tests to print.');
        return;
      }
      printFromTestsWithTable(filteredTests, `Filtered Results (${filteredTests.length} tests)`);
    }

    function printFromTestsWithTable(tests, modeLabel, selectedProducts = []) {
      const printSection = document.getElementById('printSection');
      const printMeta = document.getElementById('printMeta');
      const printChartsContainer = document.getElementById('printChartsContainer');
      const printTablesContainer = document.getElementById('printTablesContainer');

      document.getElementById('printTitle').textContent = `SpinQ Report Monitoring — ${modeLabel}`;

      // Handle "Custom Product" selection - replace __CUSTOM_PRODUCT__ with actual custom product names
      if (selectedProducts.includes('__CUSTOM_PRODUCT__')) {
        const customProducts = new Set();
        for (const t of tests) {
          // FIXED: Support both cardRows (Sliver) and rows (Count & Strength)
          const dataRows = t.cardRows || t.rows || [];
          const g = groupData(dataRows);
          Object.keys(g).forEach(p => {
            if (!PRODUCT_OPTIONS_BASE.includes(p)) {
              customProducts.add(p);
            }
          });
        }
        selectedProducts = selectedProducts.filter(p => p !== '__CUSTOM_PRODUCT__');
        selectedProducts.push(...Array.from(customProducts));
      }

      // Combine by product across tests for printing (never combine different products)
      const combinedGroups = {};
      for (const t of tests) {
        // FIXED: Support both cardRows (Sliver) and rows (Count & Strength)
        const dataRows = t.cardRows || t.rows || [];
        const g = groupData(dataRows);
        for (const p of Object.keys(g)) {
          // If products are selected, only include selected products
          if (selectedProducts.length > 0 && !selectedProducts.includes(p)) {
            continue;
          }
          if (!combinedGroups[p]) combinedGroups[p] = { cardAvgs: [], allValues: [], cardNos: [] };
          combinedGroups[p].cardAvgs.push(...g[p].cardAvgs);
          combinedGroups[p].allValues.push(...g[p].allValues);
          combinedGroups[p].cardNos.push(...g[p].cardNos);
        }
      }
      const productsPresent = Object.keys(combinedGroups)
        .filter(p => combinedGroups[p].allValues.length > 0)
        .sort((a, b) => a.localeCompare(b));

      const reportNums = tests.map(t => t.reportNumber).filter(Boolean).join(', ');
      const testDates = Array.from(new Set(tests.map(t => t.testDate).filter(Boolean))).join(', ');
      const operators = Array.from(new Set(tests.map(t => t.operatorName).filter(Boolean))).join(', ');

      // Use the first test's range, or default to 5.0 if not available
      const printRange = (tests.length > 0 && tests[0].acceptableRange !== undefined && tests[0].acceptableRange !== null) ? tests[0].acceptableRange : 5.0;

      printMeta.innerHTML = `
      <div><strong>Report #:</strong> ${escapeHtml(reportNums || '-')}</div>
      <div><strong>Date(s):</strong> ${escapeHtml(testDates || '-')}</div>
      <div><strong>Operator(s):</strong> ${escapeHtml(operators || '-')}</div>
      <div><strong>Products:</strong> ${escapeHtml(productsPresent.join(', ') || '-')}</div>
    `;

      // Calculate per-product metrics for print header
      const printMetricsData = {};
      const printRanges = {}; // Per-product ranges

      for (const p of productsPresent) {
        const g = combinedGroups[p];
        printMetricsData[p] = { totalCards: g.cardAvgs.length, totalCoilers: g.allValues.length, oocCards: 0, oocCoilers: 0 };

        // Determine range for this product (use per-product range if available, otherwise use single range)
        let productRange = printRange;
        for (const t of tests) {
          if (t.acceptableRanges && t.acceptableRanges[p] !== undefined && t.acceptableRanges[p] !== null) {
            productRange = t.acceptableRanges[p];
            break;
          } else if (t.acceptableRange !== undefined && t.acceptableRange !== null && tests.length === 1) {
            productRange = t.acceptableRange;
          }
        }
        printRanges[p] = productRange;

        // Calculate OOC for this product from all tests
        for (const t of tests) {
          const dataRows = t.cardRows || t.rows || [];
          const testGroups = groupData(dataRows);
          if (!testGroups[p]) continue;

          // Helper to parse values
          const parseLocal = (v) => {
            if (v === null || v === undefined || v === '-') return NaN;
            const s = String(v).replace(/[^\d.-]/g, '');
            return s ? parseFloat(s) : NaN;
          };

          const tgt = parseLocal(t.yarnCount || t.targetCount);
          const meanCard = meanOf(testGroups[p].cardAvgs);
          const limCard = !isNaN(tgt) ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(testGroups[p].allValues);
          const limCoiler = !isNaN(tgt) ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanAll, productRange);

          for (const r of dataRows) {
            const rowProd = (r.product || '').trim();
            if (rowProd !== p) continue;

            const rAvg = parseLocal(r.avg !== undefined ? r.avg : r.count);
            if (!isNaN(rAvg) && !withinLimits(rAvg, limCard)) {
              printMetricsData[p].oocCards++;
            }
            for (const v of (r.coilers || [])) {
              const cv = parseLocal(v);
              if (!isNaN(cv) && !withinLimits(cv, limCoiler)) {
                printMetricsData[p].oocCoilers++;
              }
            }
          }
        }
      }

      // Create metrics boxes for print with inline styles for color printing - per product
      const printMetrics = document.getElementById('printMetrics');
      let printMetricsHTML = `
      <div class="print-metric" style="background-color: #3498db !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
        <div class="label">Products Detected</div>
        <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
      </div>
    `;

      for (const p of productsPresent) {
        const metrics = printMetricsData[p];
        const g = combinedGroups[p];
        const rangeStr = printRanges[p].toFixed(1);
        const cardsBgColor = metrics.oocCards > 0 ? '#e74c3c' : '#3498db';
        const coilersBgColor = metrics.oocCoilers > 0 ? '#e74c3c' : '#3498db';

        const cardMin = g.cardAvgs && g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs).toFixed(2) : '-';
        const cardMax = g.cardAvgs && g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs).toFixed(2) : '-';
        const coilerMin = g.allValues && g.allValues.length > 0 ? Math.min(...g.allValues).toFixed(3) : '-';
        const coilerMax = g.allValues && g.allValues.length > 0 ? Math.max(...g.allValues).toFixed(3) : '-';

        printMetricsHTML += `
        <div class="print-metric" style="background-color: ${cardsBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCards} out of ${metrics.totalCards}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
        </div>
        <div class="print-metric" style="background-color: ${coilersBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCoilers} out of ${metrics.totalCoilers}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${coilerMin} | Max: ${coilerMax}</div>
        </div>
      `;
      }

      printMetrics.innerHTML = printMetricsHTML;

      printChartsContainer.innerHTML = '';
      printTablesContainer.innerHTML = '';

      // Destroy old print charts
      for (const ch of printChartInstances.values()) ch.destroy();
      printChartInstances.clear();

      // Charts grid
      const grid = document.createElement('div');
      grid.className = 'print-grid';
      printChartsContainer.appendChild(grid);

      // For combined printing, there is no single target per product (targets may differ per test),
      // so we only show target line when printing exactly one test.
      const singleTestTargets = (tests.length === 1 && tests[0].targets) ? tests[0].targets : {};

      for (let i = 0; i < productsPresent.length; i++) {
        const p = productsPresent[i];
        const g = combinedGroups[p];

        // Only show All Coiler Readings chart (not Card Averages)
        if (g.allValues.length > 0) {
          const id = `print_all_${safeId(p)}`;
          grid.appendChild(makePrintChartCard(`${p} — All Coiler Readings`, id));
          const mean = meanOf(g.allValues);
          const { lcl, ucl } = limitsFromMean(mean, printRange);
          const tval = (tests.length === 1 && singleTestTargets[p] !== null && isFinite(singleTestTargets[p])) ? singleTestTargets[p] : null;
          plotDistribution(id, g.allValues, mean, lcl, ucl, `Product: ${p} (All Coiler Readings)`, printChartInstances, tval);
        }
      }

      // Create detailed sorted table with all individual values (filter by selected products if specified)
      const allRows = [];
      for (const test of tests) {
        const dataRows = test.cardRows || test.rows || [];
        for (const row of dataRows) {
          const rowProduct = (row.product || '').trim();
          // If products are selected, only include rows for selected products
          if (selectedProducts.length > 0 && !selectedProducts.includes(rowProduct)) {
            continue;
          }
          allRows.push({
            ...row,
            testDate: test.testDate,
            dateTime: test.dateTime,
            reportNumber: test.reportNumber,
            operatorName: test.operatorName,
            product: rowProduct,
            sample: row.cardNo || row.sample || '?',
            target: parseVal(test.yarnCount || test.targetCount)
          });
        }
      }

      // Sort by test date, then by card number
      allRows.sort((a, b) => {
        const dateA = a.testDate ? new Date(a.testDate) : new Date(0);
        const dateB = b.testDate ? new Date(b.testDate) : new Date(0);
        if (dateA.getTime() !== dateB.getTime()) {
          return dateA.getTime() - dateB.getTime();
        }
        return a.cardNo - b.cardNo;
      });

      const tableDiv = document.createElement('div');
      tableDiv.innerHTML = `<h3 style="margin: 12px 0 8px; font-size: 14px; font-weight: bold;">Detailed Data (Sorted by Date, then Card Number)</h3>`;
      const table = document.createElement('table');
      table.style.borderCollapse = 'collapse';
      table.style.width = '100%';
      table.style.fontSize = '11px';
      table.innerHTML = `
      <thead>
        <tr style="background: #f3f4f6; font-weight: bold;">
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Test Date</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Report #</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Operator</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Card #</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: left;">Product</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Target (g/m)</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 1</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 2</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 3</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Coiler 4</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Avg</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Min</th>
          <th style="padding: 8px; border: 1px solid #d1d5db; text-align: right;">Max</th>
        </tr>
      </thead>
      <tbody>
        ${allRows.map(r => {
        const coilers = r.coilers || [];
        return `
          <tr>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.testDate || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.reportNumber || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.operatorName || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: center; font-weight: bold;">${r.cardNo}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db;">${escapeHtml(r.product || '-')}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right; font-weight: 600;">${r.target !== null ? Number(r.target).toFixed(2) : '-'}</td>
            ${coilers.map(v => `<td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${v !== null && isFinite(v) ? Number(v).toFixed(3) : '-'}</td>`).join('')}
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right; font-weight: bold;">${r.avg !== null && isFinite(r.avg) ? Number(r.avg).toFixed(3) : '-'}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${(() => {
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            return coilerValues.length > 0 ? Math.min(...coilerValues).toFixed(3) : '-';
          })()}</td>
            <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${(() => {
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            return coilerValues.length > 0 ? Math.max(...coilerValues).toFixed(3) : '-';
          })()}</td>
          </tr>
        `;
      }).join('')}
      </tbody>
    `;
      tableDiv.appendChild(table);
      printTablesContainer.appendChild(tableDiv);

      // Show print view
      const mainContainer = document.querySelector('.container');
      const originalDisplay = mainContainer ? mainContainer.style.display : '';

      if (mainContainer) mainContainer.style.display = 'none';
      printSection.style.cssText = `
      display:block !important;
      visibility:visible !important;
      position:static !important;
      left:auto !important;
      top:auto !important;
      width:100% !important;
      height:auto !important;
      background:white !important;
      z-index:99999 !important;
      overflow:visible !important;
      padding:20px !important;
    `;

      const restore = () => {
        printSection.style.cssText = 'display:none; position:absolute; left:-9999px; top:0;';
        if (mainContainer) mainContainer.style.display = originalDisplay || 'block';
        for (const ch of printChartInstances.values()) ch.destroy();
        printChartInstances.clear();
      };

      window.scrollTo(0, 0);
      setTimeout(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { window.print(); } catch (e) { alert('Print failed. Use Ctrl+P / Cmd+P.'); restore(); return; }
            const after = () => { restore(); window.removeEventListener('afterprint', after); };
            window.addEventListener('afterprint', after);
            setTimeout(restore, 1400);
          });
        });
      }, 600);
    }

    function initializeFilters() {
      // Populate operators
      const saved = getSavedTests();
      const operators = Array.from(new Set(saved.map(t => t.operatorName).filter(Boolean))).sort();
      const operatorSelects = ['filterOperator', 'combinedOperator'];
      operatorSelects.forEach(selectId => {
        const select = document.getElementById(selectId);
        if (select) {
          const currentValue = select.value;
          select.innerHTML = '<option value="">All Operators</option>' + operators.map(op =>
            `<option value="${escapeHtml(op)}">${escapeHtml(op)}</option>`
          ).join('');
          select.value = currentValue;
        }
      });

      // Populate card selectors
      const cardSelectors = ['cardSelector', 'combinedCardSelector'];
      cardSelectors.forEach(selectorId => {
        const container = document.getElementById(selectorId);
        if (container) {
          container.innerHTML = '';
          for (let i = 1; i <= TOTAL_CARDS; i++) {
            const label = document.createElement('label');
            label.className = 'card-checkbox';
            label.innerHTML = `
            <input type="checkbox" value="${i}" onchange="applyFilters()">
            <span>Card ${i}</span>
          `;
            container.appendChild(label);
          }
        }
      });

      // Populate product selectors - get all unique products from saved tests
      const allProducts = new Set();
      saved.forEach(test => {
        const groups = groupData(test.cardRows || []);
        Object.keys(groups).forEach(p => {
          if (groups[p].allValues.length > 0) {
            allProducts.add(p);
          }
        });
      });
      const productList = Array.from(allProducts).sort();

      const productSelectors = ['filterProductSelector', 'cardProductSelector', 'combinedProductSelector'];
      productSelectors.forEach(selectorId => {
        const container = document.getElementById(selectorId);
        if (container) {
          container.innerHTML = '';
          productList.forEach(product => {
            const label = document.createElement('label');
            label.className = 'card-checkbox';
            label.innerHTML = `
            <input type="checkbox" value="${escapeHtml(product)}" onchange="applyFilters()">
            <span>${escapeHtml(product)}</span>
          `;
            container.appendChild(label);
          });
          // Add "Custom Product" option
          const customLabel = document.createElement('label');
          customLabel.className = 'card-checkbox';
          customLabel.innerHTML = `
          <input type="checkbox" value="__CUSTOM_PRODUCT__" onchange="applyFilters()">
          <span>Custom Product</span>
        `;
          container.appendChild(customLabel);
        }
      });
    }

    function openDetails(test, revIndex) {
      detailsTest = test;

      // Close any already open details
      closeDetails();

      const parentRow = document.getElementById(`report-row-${revIndex}`);
      if (!parentRow) return;

      // Create the detail-row
      const detailRow = document.createElement('tr');
      detailRow.className = 'detail-row';
      detailRow.id = `detail-row-${revIndex}`;

      // We have 15 columns
      detailRow.innerHTML = `
        <td colspan="15">
          <div class="inline-details-container">
            <div class="details-header" style="padding-bottom:12px; border-bottom:1px solid #e5e7eb; margin-bottom:15px; display:flex; justify-content:space-between; align-items:flex-start;">
              <div>
                <div class="details-title" style="font-size:18px; font-weight:700; color:#1e293b; margin-bottom:4px;">Report ${test.reportNumber} — Details</div>
                <div class="details-meta" style="font-size:13px; color:#64748b;"></div>
              </div>
              <div style="display:flex; gap:10px;">
                <button class="btn-muted" onclick="closeDetails()" style="margin:0;">Close</button>
                <button class="btn-print" onclick="printDetails()" style="margin:0;">Print This Report</button>
              </div>
            </div>
            
            <div id="inlineDetailsMeta"></div>

            <div class="details-charts" style="margin-bottom:20px;">
              <div id="detailsChartsGrid" class="charts-grid" style="display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:20px;"></div>
            </div>

            <div class="details-table-wrap">
              <h3 style="margin: 6px 0 10px; color:#1e293b; font-size:16px;">Detailed Data</h3>
              <div style="overflow:auto; max-height:400px; border:1px solid #e2e8f0; border-radius:8px;">
                <table id="detailsTable" style="width:100%; border-collapse:collapse;"></table>
              </div>
            </div>
          </div>
        </td>
      `;

      // Insert after parent row
      parentRow.parentNode.insertBefore(detailRow, parentRow.nextSibling);

      const isCountStrength = test.testType === 'Count & Strength';

      if (isCountStrength) {
        // --- Count & Strength Details ---
        document.getElementById('inlineDetailsMeta').innerHTML = `
          <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:12px; font-size:13px; color:#1e293b; margin-bottom:15px;">
            <div>Date/Time: <strong>${escapeHtml(test.dateTime || '-')}</strong></div>
            <div>Machine: <strong>${escapeHtml(test.machine || '-')}</strong></div>
            <div>Product: <strong>${escapeHtml(test.product || '-')}</strong></div>
            <div>Process: <strong>${escapeHtml(test.process || '-')}</strong></div>
            <div>Lot: <strong>${escapeHtml(test.lotNumber || '-')}</strong></div>
            <div>Target Count: <strong>${escapeHtml(test.yarnCount || '-')}</strong></div>
          </div>
          <div style="margin-bottom:20px; padding:12px; background:#f1f5f9; border-radius:8px; display:flex; flex-wrap:wrap; gap:20px; font-size:14px; border:1px solid #e2e8f0;">
            <span>Avg Count: <strong>${test.avgCount || '-'}</strong></span>
            <span>Count CV%: <strong>${test.countCV || '-'}</strong></span>
            <span>Avg Strength: <strong>${test.avgStrength || '-'}</strong></span>
            <span>CSP: <strong>${test.avgCSP || '-'}</strong></span>
            <span>Out of Limit: <strong style="color:${parseFloat(test.outOfLimitCount) > 0 ? '#ef4444' : 'inherit'}">${test.outOfLimitCount || '0.0'}%</strong></span>
          </div>
        `;

        const t = document.getElementById('detailsTable');
        t.innerHTML = `
          <thead>
            <tr>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Sample</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Pos</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Weight (g)</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Source</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Count (Ne)</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Strength (lbs)</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-bottom:1px solid #e2e8f0;">CSP</th>
            </tr>
          </thead>
          <tbody>
            ${(test.rows || []).map(r => `
              <tr>
                <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;"><strong>${r.sample}</strong></td>
                <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${r.pos || '-'}</td>
                <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${r.weight || '-'}</td>
                <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${r.source || 'Manual'}</td>
                <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;"><strong>${r.count || '-'}</strong></td>
                <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${r.strength || '-'}</td>
                <td style="padding:8px 10px; border-bottom:1px solid #e2e8f0;">${r.csp || '-'}</td>
              </tr>
            `).join('')}
          </tbody>
        `;

        // Render Charts for Count & Strength
        destroyChartMap(detailsChartInstances, 'detailsChartsGrid');
        const grid = document.getElementById('detailsChartsGrid');

        if (test.rawData) {
          const countChartId = 'details_count_dist';
          const strengthChartId = 'details_strength_dist';
          grid.appendChild(makeChartCard('Count Distribution', countChartId));
          grid.appendChild(makeChartCard('Strength Distribution', strengthChartId));

          const counts = test.rawData.counts || [];
          const strengths = test.rawData.strengths || [];
          const avgCount = parseFloat(test.avgCount);
          const avgStrength = parseFloat(test.avgStrength);
          const rangeVal = test.rangePercent || 2.5;
          const lcl = parseFloat(test.lcl);
          const ucl = parseFloat(test.ucl);

          // Count Distribution
          plotDistribution(countChartId, counts, avgCount, lcl, ucl, 'Count Distribution', detailsChartInstances, parseFloat(test.yarnCount));

          // Strength Distribution
          const sLims = limitsFromMean(avgStrength, 10.0);
          plotDistribution(strengthChartId, strengths, avgStrength, sLims.lcl, sLims.ucl, 'Strength Distribution', detailsChartInstances, null);
        } else {
          grid.innerHTML = '<div style="padding:20px; color:#64748b;">No chart data saved for this report.</div>';
        }

      } else {
        // --- Sliver / Carding Details (Legacy Support) ---
        document.getElementById('inlineDetailsMeta').innerHTML = `
          <div style="font-size:14px; color:#1e293b; margin-bottom:15px;">
            Date/Time: <strong>${escapeHtml(test.dateTime || '-')}</strong> | Test Date: <strong>${escapeHtml(test.testDate || '-')}</strong> | Operator: <strong>${escapeHtml(test.operatorName || '-')}</strong><br>
            Targets: <strong>${escapeHtml(formatTargets(test.targets))}</strong>
          </div>
        `;

        const groups = groupData(test.cardRows || []);
        const productsPresent = (test.productsPresent && test.productsPresent.length)
          ? test.productsPresent
          : Object.keys(groups);

        const savedRanges = test.acceptableRanges || (test.acceptableRange !== undefined && test.acceptableRange !== null
          ? Object.fromEntries(productsPresent.map(p => [p, test.acceptableRange]))
          : Object.fromEntries(productsPresent.map(p => [p, 5.0])));

        renderGroupedCharts(groups, productsPresent.filter(p => groups[p] && groups[p].allValues.length > 0), 'detailsChartsGrid', detailsChartInstances, test.targets || {}, savedRanges);

        const t = document.getElementById('detailsTable');
        const targets = test.targets || {};
        t.innerHTML = `
          <thead>
            <tr>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Card #</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Product</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Target (g/m)</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">C1</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">C2</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">C3</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:10px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">C4</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:10px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Avg</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-right:10px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">Min</th>
              <th style="background:#f8fafc; padding:10px; text-align:left; border-bottom:1px solid #e2e8f0;">Max</th>
            </tr>
          </thead>
          <tbody>
            ${(test.cardRows || []).map(r => {
          const targetValue = (r.product && targets[r.product] !== null && targets[r.product] > 0)
            ? targets[r.product].toFixed(2)
            : '-';
          const coilers = (r.coilers || []).filter(v => v !== null && isFinite(v)).map(v => Number(v));
          const coilerMin = coilers.length > 0 ? Math.min(...coilers).toFixed(3) : '-';
          const coilerMax = coilers.length > 0 ? Math.max(...coilers).toFixed(3) : '-';
          return `
                <tr>
                  <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;"><strong>${r.cardNo}</strong></td>
                  <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${escapeHtml(r.product || '')}</td>
                  <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0; font-weight: 600; color: #2c3e50;">${targetValue}</td>
                  ${(r.coilers || []).map(v => `<td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${v !== null && isFinite(v) ? Number(v).toFixed(3) : '-'}</td>`).join('')}
                  <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;"><strong>${r.avg !== null && isFinite(r.avg) ? Number(r.avg).toFixed(3) : '-'}</strong></td>
                  <td style="padding:8px 10px; border-right:1px solid #e2e8f0; border-bottom:1px solid #e2e8f0;">${coilerMin}</td>
                  <td style="padding:8px 10px; border-bottom:1px solid #e2e8f0;">${coilerMax}</td>
                </tr>
              `;
        }).join('')}
          </tbody>
        `;
      }
    }

    function closeDetails() {
      detailsTest = null;
      destroyChartMap(detailsChartInstances, 'detailsChartsGrid');
      const oldRow = document.querySelector('.detail-row');
      if (oldRow) oldRow.parentNode.removeChild(oldRow);
    }

    // -----------------------------
    // Printing (multi-page, per product breaks)
    // -----------------------------
    function printDetails() {
      if (!detailsTest) return;
      if (detailsTest.testType === 'Count & Strength' || detailsTest.rawData) {
        printCountStrengthTest(detailsTest, 'all');
      } else {
        printFromTests([detailsTest], `Saved Report ${detailsTest.reportNumber}`);
      }
    }

    function printCurrent(mode = 'all') {
      if (!currentTest) { alert('Please calculate results first.'); return; }
      // Route to appropriate print function based on test type
      console.log('Print Current - Test Type:', currentTest.testType);
      console.log('Print Mode:', mode);
      console.log('Current Test:', currentTest);
      // Check both testType and presence of rawData (Count & Strength specific)
      if (currentTest.testType === 'Count & Strength' || currentTest.rawData) {
        printCountStrengthTest(currentTest, mode);
      } else {
        printFromTestsWithTable([currentTest], `Current Test ${currentTest.reportNumber}`);
      }
    }

    let isPrinting = false; // Guard flag to prevent double-calling

    function printCountStrengthTest(test, mode = 'all') {
      console.log('printCountStrengthTest called with mode:', mode, 'isPrinting:', isPrinting);
      console.trace('Call stack');

      if (isPrinting) {
        console.warn('Already printing, ignoring duplicate call');
        return;
      }
      isPrinting = true;

      const printSection = document.getElementById('printSection');
      const printMeta = document.getElementById('printMeta');
      const printChartsContainer = document.getElementById('printChartsContainer');
      const printTablesContainer = document.getElementById('printTablesContainer');
      const printMetrics = document.getElementById('printMetrics');

      // Update title based on mode
      let titleSuffix = '';
      if (mode === 'countOnly') titleSuffix = ' (Count Chart Only)';
      else if (mode === 'noCharts') titleSuffix = ' (No Charts)';

      document.getElementById('printTitle').textContent = `Count and Skein Strength Test — Report ${test.reportNumber}${titleSuffix}`;

      // Print metadata
      printMeta.innerHTML = `
        <div><strong>Report #:</strong> ${escapeHtml(test.reportNumber || '-')}</div>
        <div><strong>Test Date:</strong> ${escapeHtml(test.testDate || '-')}</div>
        <div><strong>Operator:</strong> ${escapeHtml(test.operatorName || '-')}</div>
        <div><strong>Machine:</strong> ${escapeHtml(test.machineId || '-')} | <strong>Product:</strong> ${escapeHtml(test.product || '-')} | <strong>Process:</strong> ${escapeHtml(test.process || '-')}</div>
        <div><strong>Lot Number:</strong> ${escapeHtml(test.lotNumber || '-')} | <strong>Yarn Count:</strong> ${escapeHtml(test.yarnCount || '-')}</div>
      `;

      // Print metrics with conditional styling
      const countMetricStyle = (parseFloat(test.avgCount) < parseFloat(test.lcl) || parseFloat(test.avgCount) > parseFloat(test.ucl)) ?
        'background-color: #ef4444 !important;' : 'background-color: #3498db !important;';

      const cvNum = parseFloat(test.countCV);
      const cvMetricStyle = (cvNum > 1.5) ?
        'background-color: #ef4444 !important;' : 'background-color: #3498db !important;';

      const outOfLimitPercent = test.outOfLimitPercent || '0.0';
      const outOfLimitStyle = (parseFloat(outOfLimitPercent) > 0) ?
        'background-color: #ef4444 !important;' : 'background-color: #3498db !important;';

      printMetrics.innerHTML = `
        <div class="print-metric" style="${countMetricStyle} -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">Avg Count (Ne)</div>
          <div class="value">${test.avgCount || '-'}</div>
        </div>
        <div class="print-metric" style="background-color: #3498db !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">Avg Strength (lbs)</div>
          <div class="value">${test.avgStrength || '-'}</div>
        </div>
        <div class="print-metric" style="background-color: #3498db !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">Avg CSP</div>
          <div class="value">${test.avgCSP || '-'}</div>
        </div>
        <div class="print-metric" style="${cvMetricStyle} -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">Count CV%</div>
          <div class="value">${test.countCV || '-'}%</div>
        </div>
        <div class="print-metric" style="${outOfLimitStyle} -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">Out of Limit</div>
          <div class="value">${outOfLimitPercent}%</div>
        </div>
        <div class="print-metric" style="background-color: #f8f9fa !important; color: #333 !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">LCL / UCL</div>
          <div class="value">${test.lcl || '-'} / ${test.ucl || '-'}</div>
        </div>
      `;

      printChartsContainer.innerHTML = '';
      printTablesContainer.innerHTML = '';

      // Destroy old print charts
      for (const ch of printChartInstances.values()) ch.destroy();
      printChartInstances.clear();

      // Create charts grid only if mode is not 'noCharts'
      console.log('Print mode:', mode, 'Mode check:', mode !== 'noCharts');
      if (mode !== 'noCharts') {
        const grid = document.createElement('div');
        grid.className = 'print-grid';
        printChartsContainer.appendChild(grid);

        // Get data from test
        const counts = test.rawData?.counts || [];
        const strengths = test.rawData?.strengths || [];
        const csps = test.rawData?.csps || [];

        console.log('Counts length:', counts.length, 'Strengths length:', strengths.length);
        console.log('Chart conditions - Count:', counts.length > 0 && (mode === 'all' || mode === 'countOnly'));
        console.log('Chart conditions - Strength:', strengths.length > 0 && mode === 'all');

        // Count chart - always show for 'all' and 'countOnly' modes
        if (counts.length > 0 && (mode === 'all' || mode === 'countOnly')) {
          console.log('Creating Count chart...');
          const countChartId = 'print_count_dist';
          grid.appendChild(makePrintChartCard(`Count Distribution (Ne) - Limits +/-${test.rangePercent || 2.5}%`, countChartId));
          const countMean = parseFloat(test.avgCount);
          const lcl = parseFloat(test.lcl);
          const ucl = parseFloat(test.ucl);
          const selCountEl = document.getElementById('selCount');
          const selCountVal = selCountEl ? selCountEl.value : '';
          const valMatch = selCountVal.match(/[\d.]+/);
          const countTarget = valMatch ? parseFloat(valMatch[0]) : null;
          plotDistribution(countChartId, counts, countMean, lcl, ucl, 'Count Distribution', printChartInstances, countTarget);
          console.log('Count chart created');
        }

        // Strength chart - only show for 'all' mode
        if (strengths.length > 0 && mode === 'all') {
          console.log('Creating Strength chart...');
          const strengthChartId = 'print_strength_dist';
          grid.appendChild(makePrintChartCard('Strength Distribution (lbs)', strengthChartId));
          const strengthMean = parseFloat(test.avgStrength);
          const strengthLims = limitsFromMean(strengthMean, 10.0);
          plotDistribution(strengthChartId, strengths, strengthMean, strengthLims.lcl, strengthLims.ucl, 'Strength Distribution', printChartInstances, null);
          console.log('Strength chart created');
        }

        console.log('After chart creation - Chart instances:', printChartInstances.size);
      }

      // Create individual test results table
      const tableDiv = document.createElement('div');
      tableDiv.innerHTML = `<h3 style="margin: 12px 0 8px; font-size: 14px; font-weight: bold;">Individual Sample Results</h3>`;
      const table = document.createElement('table');
      table.style.borderCollapse = 'collapse';
      table.style.width = '100%';
      table.style.fontSize = '11px';

      // Build table rows from the actual test table data
      const testRows = document.querySelectorAll('#testTableBody tr');
      let tableBodyHTML = '';
      let sampleNum = 1;

      testRows.forEach((row, idx) => {
        const weightInput = row.querySelector('.weight-val');
        const strengthInput = row.querySelector('.strength-val');
        const countCell = row.querySelector('.count-val');
        const cspCell = row.querySelector('.csp-val');
        const statusCell = row.querySelector('.status-cell');

        if (weightInput && strengthInput && countCell && cspCell) {
          const weight = weightInput.value || '-';
          const strength = strengthInput.value || '-';
          const count = countCell.textContent || '-';
          const csp = cspCell.textContent || '-';
          const status = statusCell ? statusCell.textContent : '-';
          const statusColor = (status === 'OOC') ? '#ef4444' : '#10b981';
          const rowBg = (status === 'OOC') ? '#fef2f2' : '';

          tableBodyHTML += `
            <tr style="background: ${rowBg};">
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: center;">${sampleNum}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: center;">${idx + 1}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${weight}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: center; color: #666;">${row.querySelector('.source-cell')?.textContent || 'Manual'}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${count}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${strength}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: right;">${csp}</td>
              <td style="padding: 6px 8px; border: 1px solid #d1d5db; text-align: center; font-weight: bold; color: ${statusColor};">${status}</td>
            </tr>
          `;
          sampleNum++;
        }
      });

      table.innerHTML = `
        <thead>
          <tr style="background: #f3f4f6; font-weight: bold;">
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Sample #</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Position #</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Weight (g)</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Source</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Count (Ne)</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Strength (lbs)</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">CSP (Calc)</th>
            <th style="padding: 8px; border: 1px solid #d1d5db; text-align: center;">Status</th>
          </tr>
        </thead>
        <tbody>
          ${tableBodyHTML}
        </tbody>
      `;
      tableDiv.appendChild(table);
      printTablesContainer.appendChild(tableDiv);

      // Show print view
      const mainContainer = document.querySelector('.container');
      const originalDisplay = mainContainer ? mainContainer.style.display : '';

      if (mainContainer) mainContainer.style.display = 'none';
      printSection.style.cssText = `
        display:block !important;
        visibility:visible !important;
        position:static !important;
        left:auto !important;
        top:auto !important;
        width:100% !important;
        height:auto !important;
        background:white !important;
        z-index:99999 !important;
        overflow:visible !important;
        padding:20px !important;
      `;

      const restore = () => {
        isPrinting = false; // Reset guard flag
        printSection.style.cssText = 'display:none; position:absolute; left:-9999px; top:0;';
        if (mainContainer) mainContainer.style.display = originalDisplay || 'block';
        for (const ch of printChartInstances.values()) ch.destroy();
        printChartInstances.clear();
      };

      window.scrollTo(0, 0);
      setTimeout(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            console.log('About to print. Chart instances:', printChartInstances.size);
            console.log('Print charts container children:', printChartsContainer.children.length);
            try { window.print(); } catch (e) { alert('Print failed. Use Ctrl+P / Cmd+P.'); restore(); return; }
            const after = () => { restore(); window.removeEventListener('afterprint', after); };
            window.addEventListener('afterprint', after);
            setTimeout(restore, 1400);
          });
        });
      }, 800); // Reduced delay now that double-call issue is fixed
    }

    function printSelected() {
      const indices = getSelectedSavedIndices();
      if (indices.length === 0) { alert('Please select at least one saved test.'); return; }
      const saved = getSavedTests();
      const selectedTests = indices.map(i => saved[i]).filter(Boolean);

      if (selectedTests.length === 1 && (selectedTests[0].testType === 'Count & Strength' || selectedTests[0].rawData)) {
        printCountStrengthTest(selectedTests[0], 'all');
      } else {
        printFromTests(selectedTests, `Selected Tests (${selectedTests.length})`);
      }
    }

    function printFromTests(tests, modeLabel) {
      const printSection = document.getElementById('printSection');
      const printMeta = document.getElementById('printMeta');
      const printChartsContainer = document.getElementById('printChartsContainer');
      const printTablesContainer = document.getElementById('printTablesContainer');

      document.getElementById('printTitle').textContent = `SpinQ Report Monitoring — ${modeLabel}`;

      // Combine by product across tests for printing
      const combinedGroups = {};
      for (const t of tests) {
        const g = groupData(t.cardRows || []);
        for (const p of Object.keys(g)) {
          if (!combinedGroups[p]) combinedGroups[p] = { cardAvgs: [], allValues: [], cardNos: [] };
          combinedGroups[p].cardAvgs.push(...g[p].cardAvgs);
          combinedGroups[p].allValues.push(...g[p].allValues);
          combinedGroups[p].cardNos.push(...g[p].cardNos);
        }
      }
      const productsPresent = Object.keys(combinedGroups)
        .filter(p => combinedGroups[p].allValues.length > 0)
        .sort((a, b) => a.localeCompare(b));

      const reportNums = tests.map(t => t.reportNumber).filter(Boolean).join(', ');
      const testDates = Array.from(new Set(tests.map(t => t.testDate).filter(Boolean))).join(', ');
      const operators = Array.from(new Set(tests.map(t => t.operatorName).filter(Boolean))).join(', ');

      // Use the first test's range, or default to 5.0 if not available
      const printRange = (tests.length > 0 && tests[0].acceptableRange !== undefined && tests[0].acceptableRange !== null) ? tests[0].acceptableRange : 5.0;

      printMeta.innerHTML = `
      <div><strong>Report #:</strong> ${escapeHtml(reportNums || '-')}</div>
      <div><strong>Date(s):</strong> ${escapeHtml(testDates || '-')}</div>
      <div><strong>Operator(s):</strong> ${escapeHtml(operators || '-')}</div>
      <div><strong>Products:</strong> ${escapeHtml(productsPresent.join(', ') || '-')}</div>
    `;

      // Calculate per-product metrics for print header
      const printMetricsData = {};
      const printRanges = {}; // Per-product ranges

      for (const p of productsPresent) {
        const g = combinedGroups[p];
        printMetricsData[p] = { totalCards: g.cardAvgs.length, totalCoilers: g.allValues.length, oocCards: 0, oocCoilers: 0 };

        // Determine range for this product (use per-product range if available, otherwise use single range)
        let productRange = printRange;
        for (const t of tests) {
          if (t.acceptableRanges && t.acceptableRanges[p] !== undefined && t.acceptableRanges[p] !== null) {
            productRange = t.acceptableRanges[p];
            break;
          } else if (t.acceptableRange !== undefined && t.acceptableRange !== null && tests.length === 1) {
            productRange = t.acceptableRange;
          }
        }
        printRanges[p] = productRange;

        // Calculate OOC for this product from all tests
        for (const t of tests) {
          const testGroups = groupData(t.cardRows || []);
          if (!testGroups[p]) continue;

          const tgt = t.targets && t.targets[p] ? t.targets[p] : null;
          const meanCard = meanOf(testGroups[p].cardAvgs);
          const limCard = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanCard, productRange);
          const meanAll = meanOf(testGroups[p].allValues);
          const limCoiler = tgt ? limitsFromTarget(tgt, productRange) : limitsFromMean(meanAll, productRange);

          for (const r of t.cardRows || []) {
            if ((r.product || '').trim() !== p) continue;
            if (r.avg !== null && isFinite(r.avg) && !withinLimits(Number(r.avg), limCard)) {
              printMetricsData[p].oocCards++;
            }
            for (const v of (r.coilers || [])) {
              if (v !== null && isFinite(v) && !withinLimits(Number(v), limCoiler)) {
                printMetricsData[p].oocCoilers++;
              }
            }
          }
        }
      }

      // Create metrics boxes for print with inline styles for color printing - per product
      const printMetrics = document.getElementById('printMetrics');
      let printMetricsHTML = `
      <div class="print-metric" style="background-color: #3498db !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
        <div class="label">Products Detected</div>
        <div class="value">${escapeHtml(productsPresent.join(', ') || '-')}</div>
      </div>
    `;

      for (const p of productsPresent) {
        const metrics = printMetricsData[p];
        const g = combinedGroups[p];
        const rangeStr = printRanges[p].toFixed(1);
        const cardsBgColor = metrics.oocCards > 0 ? '#e74c3c' : '#3498db';
        const coilersBgColor = metrics.oocCoilers > 0 ? '#e74c3c' : '#3498db';

        const cardMin = g.cardAvgs && g.cardAvgs.length > 0 ? Math.min(...g.cardAvgs).toFixed(2) : '-';
        const cardMax = g.cardAvgs && g.cardAvgs.length > 0 ? Math.max(...g.cardAvgs).toFixed(2) : '-';
        const coilerMin = g.allValues && g.allValues.length > 0 ? Math.min(...g.allValues).toFixed(3) : '-';
        const coilerMax = g.allValues && g.allValues.length > 0 ? Math.max(...g.allValues).toFixed(3) : '-';

        printMetricsHTML += `
        <div class="print-metric" style="background-color: ${cardsBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Cards Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCards} out of ${metrics.totalCards}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${cardMin} | Max: ${cardMax}</div>
        </div>
        <div class="print-metric" style="background-color: ${coilersBgColor} !important; -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important;">
          <div class="label">${escapeHtml(p)} - Coiler Readings Out-of-Control (Target ±${rangeStr}%)</div>
          <div class="value">${metrics.oocCoilers} out of ${metrics.totalCoilers}</div>
          <div class="value" style="font-size: 9px; margin-top: 2px; opacity: 0.9;">Min: ${coilerMin} | Max: ${coilerMax}</div>
        </div>
      `;
      }

      printMetrics.innerHTML = printMetricsHTML;

      printChartsContainer.innerHTML = '';
      printTablesContainer.innerHTML = '';

      // Destroy old print charts
      for (const ch of printChartInstances.values()) ch.destroy();
      printChartInstances.clear();

      // Charts grid
      const grid = document.createElement('div');
      grid.className = 'print-grid';
      printChartsContainer.appendChild(grid);

      // For combined printing, there is no single target per product (targets may differ per test),
      // so we only show target line when printing exactly one test.
      const singleTestTargets = (tests.length === 1 && tests[0].targets) ? tests[0].targets : {};

      for (let i = 0; i < productsPresent.length; i++) {
        const p = productsPresent[i];
        const g = combinedGroups[p];

        // Only show All Coiler Readings chart (not Card Averages)
        if (g.allValues.length > 0) {
          const id = `print_all_${safeId(p)}`;
          grid.appendChild(makePrintChartCard(`${p} — All Coiler Readings`, id));
          const mean = meanOf(g.allValues);
          const { lcl, ucl } = limitsFromMean(mean, printRange);
          const tval = (tests.length === 1 && singleTestTargets[p] !== null && isFinite(singleTestTargets[p])) ? singleTestTargets[p] : null;
          plotDistribution(id, g.allValues, mean, lcl, ucl, `Product: ${p} (All Coiler Readings)`, printChartInstances, tval);
        }

        // Remove page breaks between products to save pages - only break if needed for layout
      }

      // Combined summary table (mean-based)
      const summary = document.createElement('div');
      summary.innerHTML = `<h3 style="margin: 6px 0; font-size: 14px;">Combined Summary by Product</h3>`;
      const table = document.createElement('table');
      table.innerHTML = `
      <thead>
        <tr>
          <th>Product</th>
          <th># Card Avgs</th>
          <th># Coiler Values</th>
          <th>Mean (Card Avg)</th>
          <th>LCL (Card Avg)</th>
          <th>UCL (Card Avg)</th>
          <th>Mean (All)</th>
          <th>LCL (All)</th>
          <th>UCL (All)</th>
        </tr>
      </thead>
      <tbody>
        ${productsPresent.map(p => {
        const g = combinedGroups[p];
        const cardMean = g.cardAvgs.length ? meanOf(g.cardAvgs) : null;
        const cardLim = cardMean !== null ? limitsFromMean(cardMean, printRange) : { lcl: null, ucl: null };
        const allMean = g.allValues.length ? meanOf(g.allValues) : null;
        const allLim = allMean !== null ? limitsFromMean(allMean, printRange) : { lcl: null, ucl: null };
        return `
            <tr>
              <td><strong>${escapeHtml(p)}</strong></td>
              <td>${g.cardAvgs.length}</td>
              <td>${g.allValues.length}</td>
              <td>${cardMean === null ? '-' : cardMean.toFixed(2)}</td>
              <td>${cardLim.lcl === null ? '-' : cardLim.lcl.toFixed(2)}</td>
              <td>${cardLim.ucl === null ? '-' : cardLim.ucl.toFixed(2)}</td>
              <td>${allMean === null ? '-' : allMean.toFixed(3)}</td>
              <td>${allLim.lcl === null ? '-' : allLim.lcl.toFixed(3)}</td>
              <td>${allLim.ucl === null ? '-' : allLim.ucl.toFixed(3)}</td>
            </tr>
          `;
      }).join('')}
      </tbody>
    `;
      summary.appendChild(table);
      printTablesContainer.appendChild(summary);

      // Show print view (static flow; multi-page supported)
      const mainContainer = document.querySelector('.container');
      const originalDisplay = mainContainer ? mainContainer.style.display : '';

      if (mainContainer) mainContainer.style.display = 'none';
      printSection.style.cssText = `
      display:block !important;
      visibility:visible !important;
      position:static !important;
      left:auto !important;
      top:auto !important;
      width:100% !important;
      height:auto !important;
      background:white !important;
      z-index:99999 !important;
      overflow:visible !important;
      padding:20px !important;
    `;

      const restore = () => {
        printSection.style.cssText = 'display:none; position:absolute; left:-9999px; top:0;';
        if (mainContainer) mainContainer.style.display = originalDisplay || 'block';
        for (const ch of printChartInstances.values()) ch.destroy();
        printChartInstances.clear();
      };

      window.scrollTo(0, 0);
      setTimeout(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { window.print(); } catch (e) { alert('Print failed. Use Ctrl+P / Cmd+P.'); restore(); return; }
            const after = () => { restore(); window.removeEventListener('afterprint', after); };
            window.addEventListener('afterprint', after);
            setTimeout(restore, 1400);
          });
        });
      }, 600);
    }

    function makePrintChartCard(title, canvasId) {
      const wrap = document.createElement('div');
      wrap.className = 'avoid-break';
      wrap.style.border = '1px solid #e5e7eb';
      wrap.style.borderRadius = '8px';
      wrap.style.padding = '6px';
      wrap.style.boxShadow = '0 1px 6px rgba(0,0,0,0.06)';

      const h = document.createElement('h3');
      h.textContent = title;
      h.style.margin = '0 0 4px';
      h.style.fontSize = '13px';
      h.style.fontWeight = 'bold';
      wrap.appendChild(h);

      const canvas = document.createElement('canvas');
      canvas.id = canvasId;
      wrap.appendChild(canvas);

      return wrap;
    }

    // -----------------------------
    // Export Functions (Excel & PDF)
    // -----------------------------
    function exportToExcel() {
      try {
        const saved = getSavedTests();
        const indices = getSelectedSavedIndices();

        // Determine which tests to export
        let testsToExport = [];
        if (indices.length > 0) {
          // Export selected tests
          testsToExport = indices.map(i => saved[i]).filter(Boolean);
        } else if (filteredTests.length > 0) {
          // Export filtered tests
          testsToExport = filteredTests;
        } else {
          // Export all tests
          testsToExport = saved;
        }

        if (testsToExport.length === 0) {
          alert('No tests to export.');
          return;
        }

        // Create workbook
        const wb = XLSX.utils.book_new();

        // Summary sheet
        const summaryData = [
          ['Date Time', 'Report #', 'Machine', 'Product', 'Process', 'Lot', 'Count (Target)', 'Avg count', 'Count CV%', 'Avg Strength', 'CSP', 'Out of limit', 'Operator']
        ];

        testsToExport.forEach(test => {
          if (test.testType === 'Count & Strength') {
            const isLegacy = !test.hasOwnProperty('process');
            let machineVal = test.machine || test.machineId || (isLegacy ? (test.testDate || '-') : '-');
            let productVal = test.product || (isLegacy ? (test.operatorName || '-') : '-');
            let processVal = test.process || (isLegacy ? (test.targetCount || '-') : '-');
            let lotVal = test.lotNumber || (isLegacy ? (test.product || '-') + (test.metrics ? ` (${test.metrics.avgCount})` : '') : '-');

            summaryData.push([
              test.dateTime || 'N/A',
              test.reportNumber || 'N/A',
              machineVal,
              productVal,
              processVal,
              lotVal,
              test.yarnCount || test.targetCount || '-',
              test.avgCount || test.metrics?.avgCount || '-',
              test.countCV || test.metrics?.countCV || '-',
              test.avgStrength || test.metrics?.avgStrength || '-',
              test.avgCSP || test.metrics?.avgCSP || '-',
              (test.outOfLimitCount || '0.0') + '%',
              test.operatorName || 'N/A'
            ]);
          } else {
            const summary = formatProductSummary(test.summaryByProduct);
            const targetsText = (typeof formatTargets === 'function') ? formatTargets(test.targets) : (test.yarnCount || test.targetCount || '-');
            summaryData.push([
              test.dateTime || 'N/A',
              test.reportNumber || 'N/A',
              'Sliver',
              test.product || 'Various',
              '-',
              '-',
              targetsText,
              '-',
              '-',
              '-',
              '-',
              (test.oocCardsAll || 0) + '/' + (test.oocCoilersAll || 0),
              test.operatorName || 'N/A'
            ]);
          }
        });

        const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
        XLSX.utils.book_append_sheet(wb, wsSummary, 'Summary');

        // Detailed data sheet
        const detailedData = [
          ['Test Date', 'Report #', 'Operator', 'Card #', 'Product', 'Target (g/m)', 'Coiler 1', 'Coiler 2', 'Coiler 3', 'Coiler 4', 'Avg', 'Min', 'Max']
        ];

        testsToExport.forEach(test => {
          const targets = test.targets || {};
          (test.cardRows || []).forEach(row => {
            const coilers = row.coilers || [];
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            const minVal = coilerValues.length > 0 ? Math.min(...coilerValues) : null;
            const maxVal = coilerValues.length > 0 ? Math.max(...coilerValues) : null;
            const targetValue = (row.product && targets[row.product] !== null && targets[row.product] > 0)
              ? targets[row.product]
              : null;

            detailedData.push([
              test.testDate || 'N/A',
              test.reportNumber || 'N/A',
              test.operatorName || 'N/A',
              row.cardNo,
              row.product || '',
              targetValue !== null ? targetValue : '',
              coilers[0] !== null && isFinite(coilers[0]) ? coilers[0] : '',
              coilers[1] !== null && isFinite(coilers[1]) ? coilers[1] : '',
              coilers[2] !== null && isFinite(coilers[2]) ? coilers[2] : '',
              coilers[3] !== null && isFinite(coilers[3]) ? coilers[3] : '',
              row.avg !== null && isFinite(row.avg) ? row.avg : '',
              minVal !== null ? minVal : '',
              maxVal !== null ? maxVal : ''
            ]);
          });
        });

        const wsDetailed = XLSX.utils.aoa_to_sheet(detailedData);
        XLSX.utils.book_append_sheet(wb, wsDetailed, 'Detailed Data');

        // Per-product statistics sheet
        const statsData = [
          ['Test Date', 'Report #', 'Product', 'Target (g/m)', 'Range (%)', 'Cards Count', 'Coilers Count', 'Card Avg Mean', 'Card Avg LCL', 'Card Avg UCL', 'All Mean', 'All LCL', 'All UCL', 'OOC Cards', 'OOC Coilers']
        ];

        testsToExport.forEach(test => {
          const groups = groupData(test.cardRows || []);
          const productsPresent = Object.keys(groups).filter(p => groups[p].allValues.length > 0);
          const ranges = test.acceptableRanges || (test.acceptableRange !== undefined && test.acceptableRange !== null
            ? Object.fromEntries(productsPresent.map(p => [p, test.acceptableRange]))
            : Object.fromEntries(productsPresent.map(p => [p, 5.0])));
          const targets = test.targets || {};

          productsPresent.forEach(product => {
            const g = groups[product];
            const productRange = ranges[product] || 5.0;
            const meanCard = meanOf(g.cardAvgs);
            const limCardMean = limitsFromMean(meanCard, productRange);
            const meanAll = meanOf(g.allValues);
            const limAllMean = limitsFromMean(meanAll, productRange);
            const tgt = targets[product] || null;

            const stats = test.productStats && test.productStats[product] ? test.productStats[product] : {
              oocCards: 0,
              oocCoilers: 0
            };

            statsData.push([
              test.testDate || 'N/A',
              test.reportNumber || 'N/A',
              product,
              tgt !== null ? tgt : '',
              productRange,
              g.cardAvgs.length,
              g.allValues.length,
              meanCard,
              limCardMean.lcl,
              limCardMean.ucl,
              meanAll,
              limAllMean.lcl,
              limAllMean.ucl,
              stats.oocCards || 0,
              stats.oocCoilers || 0
            ]);
          });
        });

        const wsStats = XLSX.utils.aoa_to_sheet(statsData);
        XLSX.utils.book_append_sheet(wb, wsStats, 'Product Statistics');

        // Generate filename
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `SpinQ_Export_${timestamp}.xlsx`;

        // Write file
        XLSX.writeFile(wb, filename);

        alert(`Exported ${testsToExport.length} test(s) to Excel successfully.`);
      } catch (e) {
        showError("Excel export failed: " + (e && e.message ? e.message : String(e)));
        console.error(e);
      }
    }

    function exportToPDF() {
      try {
        const saved = getSavedTests();
        const indices = getSelectedSavedIndices();

        // Determine which tests to export
        let testsToExport = [];
        if (indices.length > 0) {
          // Export selected tests
          testsToExport = indices.map(i => saved[i]).filter(Boolean);
        } else if (filteredTests.length > 0) {
          // Export filtered tests
          testsToExport = filteredTests;
        } else {
          // Export all tests
          testsToExport = saved;
        }

        if (testsToExport.length === 0) {
          alert('No tests to export.');
          return;
        }

        // Check if jsPDF is available
        let jsPDF;
        if (typeof window.jspdf !== 'undefined' && window.jspdf.jsPDF) {
          jsPDF = window.jspdf.jsPDF;
        } else if (typeof window.jsPDF !== 'undefined') {
          jsPDF = window.jsPDF;
        } else {
          alert('PDF library not loaded. Please refresh the page.');
          return;
        }
        const doc = new jsPDF('p', 'mm', 'a4');
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const maxWidth = pageWidth - (margin * 2);
        let yPos = margin;

        // Helper function to add a new page if needed
        function checkPageBreak(requiredHeight = 20) {
          if (yPos + requiredHeight > pageHeight - margin) {
            doc.addPage();
            yPos = margin;
            return true;
          }
          return false;
        }

        // Helper function to add text with word wrap
        function addText(text, x, y, maxWidth, fontSize = 10, fontStyle = 'normal') {
          doc.setFontSize(fontSize);
          doc.setFont('helvetica', fontStyle);
          const lines = doc.splitTextToSize(text, maxWidth);
          doc.text(lines, x, y);
          return lines.length * (fontSize * 0.35); // Approximate line height
        }

        // Title
        doc.setFontSize(16);
        doc.setFont('helvetica', 'bold');
        doc.text('SpinQ Report Monitoring - Export', margin, yPos);
        yPos += 10;

        // Export info
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        const exportDate = new Date().toLocaleString();
        doc.text(`Exported: ${exportDate}`, margin, yPos);
        doc.text(`Tests: ${testsToExport.length}`, pageWidth - margin - 30, yPos);
        yPos += 8;

        // Summary table
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.text('Summary', margin, yPos);
        yPos += 8;

        // Table headers
        const tableHeaders = ['Date/Time', 'Report #', 'Test Date', 'Operator', 'OOC Cards', 'OOC Coilers'];
        const colWidths = [35, 25, 30, 35, 25, 25];
        const startX = margin;

        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        let xPos = startX;
        tableHeaders.forEach((header, idx) => {
          doc.text(header, xPos, yPos);
          xPos += colWidths[idx];
        });
        yPos += 6;

        // Table rows
        doc.setFont('helvetica', 'normal');
        testsToExport.forEach((test, idx) => {
          checkPageBreak(10);

          if (idx > 0 && idx % 20 === 0) {
            // Add header again every 20 rows
            doc.setFont('helvetica', 'bold');
            xPos = startX;
            tableHeaders.forEach((header, hIdx) => {
              doc.text(header, xPos, yPos);
              xPos += colWidths[hIdx];
            });
            yPos += 6;
            doc.setFont('helvetica', 'normal');
          }

          xPos = startX;
          const rowData = [
            (test.dateTime || 'N/A').substring(0, 15),
            test.reportNumber || 'N/A',
            (test.testDate || 'N/A').substring(0, 10),
            (test.operatorName || 'N/A').substring(0, 15),
            String(test.oocCardsAll || 0),
            String(test.oocCoilersAll || 0)
          ];

          rowData.forEach((cell, cellIdx) => {
            doc.text(cell, xPos, yPos);
            xPos += colWidths[cellIdx];
          });
          yPos += 6;
        });

        yPos += 5;

        // Detailed data for each test
        testsToExport.forEach((test, testIdx) => {
          checkPageBreak(30);

          // Test header
          yPos += 5;
          doc.setFontSize(11);
          doc.setFont('helvetica', 'bold');
          doc.text(`Test ${testIdx + 1}: Report #${test.reportNumber}`, margin, yPos);
          yPos += 6;

          doc.setFontSize(9);
          doc.setFont('helvetica', 'normal');
          doc.text(`Date: ${test.testDate || 'N/A'} | Operator: ${test.operatorName || 'N/A'}`, margin, yPos);
          yPos += 5;

          doc.text(`Targets: ${formatTargets(test.targets)}`, margin, yPos);
          yPos += 5;

          // Detailed table for this test
          const detailHeaders = ['Card', 'Product', 'Target', 'C1', 'C2', 'C3', 'C4', 'Avg', 'Min', 'Max'];
          const detailColWidths = [12, 25, 15, 15, 15, 15, 15, 15, 15, 15];
          const detailStartX = margin;

          doc.setFont('helvetica', 'bold');
          xPos = detailStartX;
          detailHeaders.forEach((header, hIdx) => {
            doc.text(header, xPos, yPos);
            xPos += detailColWidths[hIdx];
          });
          yPos += 5;

          doc.setFont('helvetica', 'normal');
          const targets = test.targets || {};
          (test.cardRows || []).forEach(row => {
            checkPageBreak(6);

            const coilers = row.coilers || [];
            const coilerValues = coilers.filter(v => v !== null && isFinite(v)).map(v => Number(v));
            const minVal = coilerValues.length > 0 ? Math.min(...coilerValues) : null;
            const maxVal = coilerValues.length > 0 ? Math.max(...coilerValues) : null;
            const targetValue = (row.product && targets[row.product] !== null && targets[row.product] > 0)
              ? targets[row.product].toFixed(2)
              : '-';

            xPos = detailStartX;
            const detailRow = [
              String(row.cardNo),
              (row.product || '').substring(0, 12),
              targetValue,
              coilers[0] !== null && isFinite(coilers[0]) ? coilers[0].toFixed(3) : '-',
              coilers[1] !== null && isFinite(coilers[1]) ? coilers[1].toFixed(3) : '-',
              coilers[2] !== null && isFinite(coilers[2]) ? coilers[2].toFixed(3) : '-',
              coilers[3] !== null && isFinite(coilers[3]) ? coilers[3].toFixed(3) : '-',
              row.avg !== null && isFinite(row.avg) ? row.avg.toFixed(2) : '-',
              minVal !== null ? minVal.toFixed(3) : '-',
              maxVal !== null ? maxVal.toFixed(3) : '-'
            ];

            detailRow.forEach((cell, cellIdx) => {
              doc.text(cell, xPos, yPos);
              xPos += detailColWidths[cellIdx];
            });
            yPos += 5;
          });

          yPos += 3;
        });

        // Generate filename
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const filename = `SpinQ_Export_${timestamp}.pdf`;

        // Save PDF
        doc.save(filename);

        alert(`Exported ${testsToExport.length} test(s) to PDF successfully.`);
      } catch (e) {
        showError("PDF export failed: " + (e && e.message ? e.message : String(e)));
        console.error(e);
      }
    }

    let combinedChartInstances = new Map();

    function viewCombinedData() {
      const indices = getSelectedSavedIndices();
      if (indices.length < 2) return;
      const saved = getSavedTests();
      const selectedTests = indices.map(i => saved[i]).filter(Boolean);

      const panel = document.getElementById('combinedDetailsPanel');
      panel.style.display = 'block';
      panel.scrollIntoView({ behavior: 'smooth' });

      // Helper to parse values with unit prefixes like "Ne 30"
      const parseVal = (v) => {
        if (v === null || v === undefined || v === '-') return NaN;
        const s = String(v).replace(/[^\d.-]/g, '');
        return s ? parseFloat(s) : NaN;
      };

      // Calculations
      let allAvgs = [];
      let allSingles = [];
      let allCSPs = [];
      let oocTests = 0;
      let oocSingles = 0;

      // Use target/limits from first test
      const ref = selectedTests[0];
      const target = parseVal(ref.yarnCount || ref.targetCount);
      let lcl = parseVal(ref.lcl);
      let ucl = parseVal(ref.ucl);

      // Fallback limits if missing
      if (isNaN(lcl) || isNaN(ucl)) {
        const refAvg = parseVal(ref.avgCount || ref.metrics?.avgCount);
        if (!isNaN(refAvg)) {
          const lims = limitsFromMean(refAvg, 2.5);
          lcl = isNaN(lcl) ? lims.lcl : lcl;
          ucl = isNaN(ucl) ? lims.ucl : ucl;
        }
      }

      selectedTests.forEach(test => {
        const avg = parseVal(test.avgCount || test.metrics?.avgCount);
        if (!isNaN(avg)) {
          allAvgs.push(avg);
          if (!isNaN(lcl) && !isNaN(ucl)) {
            if (avg < lcl || avg > ucl) oocTests++;
          }
        }

        // Extraction of single values
        const testSingles = [];
        if (test.rawData && test.rawData.counts) {
          testSingles.push(...test.rawData.counts.map(c => parseVal(c)));
        } else if (test.rows) {
          testSingles.push(...test.rows.map(r => parseVal(r.count)));
        } else if (test.cardRows) {
          test.cardRows.forEach(r => {
            if (r.coilers) testSingles.push(...r.coilers.map(v => parseVal(v)));
          });
        }

        testSingles.filter(v => !isNaN(v)).forEach(val => {
          allSingles.push(val);
          if (!isNaN(lcl) && !isNaN(ucl)) {
            if (val < lcl || val > ucl) oocSingles++;
          }
        });

        const csp = parseVal(test.avgCSP || test.metrics?.avgCSP);
        if (!isNaN(csp)) allCSPs.push(csp);
      });

      const avgOfAvgsVal = allAvgs.length > 0 ? (allAvgs.reduce((a, b) => a + b, 0) / allAvgs.length) : NaN;
      const avgOfAvgs = !isNaN(avgOfAvgsVal) ? avgOfAvgsVal.toFixed(2) : '-';
      const avgCSPVal = allCSPs.length > 0 ? (allCSPs.reduce((a, b) => a + b, 0) / allCSPs.length) : NaN;
      const avgCSP = !isNaN(avgCSPVal) ? avgCSPVal.toFixed(0) : '-';

      // Global CV calculation
      let globalCV = '-';
      if (allSingles.length > 1) {
        const mean = allSingles.reduce((a, b) => a + b, 0) / allSingles.length;
        if (mean > 0) {
          const variance = allSingles.reduce((s, v) => s + Math.pow(v - mean, 2), 0) / (allSingles.length - 1);
          globalCV = ((Math.sqrt(variance) / mean) * 100).toFixed(2);
        }
      }

      // Render Metrics
      const metricsDiv = document.getElementById('combinedMetrics');
      if (!metricsDiv) return;

      try {
        const avgOfAvgsNum = parseFloat(avgOfAvgs);
        const avgOfAvgsStyle = (!isNaN(avgOfAvgsNum) && !isNaN(lcl) && !isNaN(ucl) && (avgOfAvgsNum < lcl || avgOfAvgsNum > ucl))
          ? 'background:#ef4444;' : 'background:#3498db;';
        const cvNum = parseFloat(globalCV);
        const cvStyle = (!isNaN(cvNum) && cvNum > 1.5) ? 'background:#ef4444;' : 'background:#3498db;';
        const oocTestsStyle = oocTests > 0 ? 'background:#ef4444;' : 'background:#3498db;';
        const oocSinglesStyle = oocSingles > 0 ? 'background:#ef4444;' : 'background:#3498db;';

        metricsDiv.innerHTML = `
          <div class="batch-metric-box" style="${avgOfAvgsStyle}">
            <div class="label">Avg of Avgs (Ne)</div>
            <div class="value">${avgOfAvgs}</div>
          </div>
          <div class="batch-metric-box" style="${cvStyle}">
            <div class="label">Global Count CV%</div>
            <div class="value">${globalCV}${globalCV !== '-' ? '%' : ''}</div>
          </div>
          <div class="batch-metric-box" style="background:#3498db;">
            <div class="label">Avg CSP</div>
            <div class="value">${avgCSP}</div>
          </div>
          <div class="batch-metric-box" style="${oocTestsStyle}">
            <div class="label">OOC Tests</div>
            <div class="value">${oocTests}</div>
          </div>
          <div class="batch-metric-box" style="${oocSinglesStyle}">
            <div class="label">OOC Single Values</div>
            <div class="value">${oocSingles}</div>
          </div>
        `;

        // Render Charts with a small delay to ensure DOM is ready
        setTimeout(() => {
          try {
            destroyChartMap(combinedChartInstances, 'combined_avg_chart_container');
            destroyChartMap(combinedChartInstances, 'combined_single_chart_container');

            const avgContainer = document.getElementById('combined_avg_chart_container');
            const singleContainer = document.getElementById('combined_single_chart_container');
            if (!avgContainer || !singleContainer) return;

            avgContainer.innerHTML = '';
            singleContainer.innerHTML = '';

            const avgChartId = 'combined_avg_chart';
            const singleChartId = 'combined_single_chart';

            avgContainer.appendChild(makeChartCard('Average Counts Distribution (By Test)', avgChartId));
            singleContainer.appendChild(makeChartCard('All Single Values Distribution', singleChartId));

            if (allAvgs.length > 0) {
              plotDistribution(avgChartId, allAvgs, parseFloat(avgOfAvgs), lcl, ucl, 'Averages Distribution', combinedChartInstances, target);
            }
            if (allSingles.length > 0) {
              plotDistribution(singleChartId, allSingles, parseFloat(avgOfAvgs), lcl, ucl, 'All Singles Distribution', combinedChartInstances, target);
            }
          } catch (chartErr) {
            console.error("Combined chart error:", chartErr);
          }
        }, 100);
      } catch (err) {
        console.error("Combined metrics error:", err);
        metricsDiv.innerHTML = '<div style="grid-column: 1/-1; padding: 20px; color: #ef4444;">Error processing combined data analysis.</div>';
      }
    }

    function closeCombinedDetails() {
      document.getElementById('combinedDetailsPanel').style.display = 'none';
      destroyChartMap(combinedChartInstances, 'combined_avg_chart_container');
      destroyChartMap(combinedChartInstances, 'combined_single_chart_container');
    }

    // -----------------------------
    // Utilities
    // -----------------------------
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, (m) => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      }[m]));
    }
    function safeId(s) {
      return String(s).toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_+|_+$/g, '');
    }

    // -----------------------------
    // RS-232 Scale Integration
    // -----------------------------
    async function initScaleConnection() {
      // Check if Web Serial API is available
      if (!navigator.serial) {
        showScaleStatus('Web Serial API not supported in this browser. Please enter values manually.', 'warning');
        return;
      }

      try {
        // Request port access
        scalePort = await navigator.serial.requestPort();

        // Open port with common scale settings: 9600 baud, 8N1
        await scalePort.open({ baudRate: 9600, dataBits: 8, parity: 'none', stopBits: 1 });

        scaleConnected = true;
        showScaleStatus('Scale connected. Reading weight values...', 'success');
        const btn = document.getElementById('scaleBtn');
        if (btn) btn.textContent = 'Disconnect Scale';

        // Start reading from scale
        readScaleData();
      } catch (error) {
        if (error.name === 'NotFoundError' || error.name === 'SecurityError') {
          // User cancelled or permission denied
          showScaleStatus('Scale not detected. Please enter values manually.', 'info');
        } else {
          showScaleStatus('Scale connection error. Please enter values manually.', 'warning');
          console.error('Scale error:', error);
        }
        scaleConnected = false;
      }
    }

    async function readScaleData() {
      if (!scalePort || !scaleConnected) return;

      try {
        const decoder = new TextDecoder();
        scaleReader = scalePort.readable.getReader();

        while (scaleConnected && scalePort.readable) {
          const { value, done } = await scaleReader.read();
          if (done) break;

          const text = decoder.decode(value);
          // Parse scale data - common formats: "4.567\r\n" or "ST,+04.567 kg\r\n" or just numbers
          const matches = text.match(/[\d.]+/g);
          if (matches && matches.length > 0) {
            const weight = parseFloat(matches[0]);
            if (!isNaN(weight) && weight > 0) {
              currentScaleValue = weight;
              // Update the focused input field if any
              const activeElement = document.activeElement;
              if (activeElement && activeElement.type === 'number' && activeElement.id.startsWith('coiler_')) {
                activeElement.value = weight.toFixed(3);
                // Trigger change event
                const event = new Event('change', { bubbles: true });
                activeElement.dispatchEvent(event);
              }
            }
          }
        }
      } catch (error) {
        if (scaleConnected) {
          showScaleStatus('Scale reading error. Please enter values manually.', 'warning');
          console.error('Scale read error:', error);
        }
        scaleConnected = false;
      } finally {
        if (scaleReader) {
          scaleReader.releaseLock();
          scaleReader = null;
        }
      }
    }

    async function disconnectScale() {
      scaleConnected = false;
      if (scaleReader) {
        try {
          await scaleReader.cancel();
        } catch (e) { }
        try {
          scaleReader.releaseLock();
        } catch (e) { }
        scaleReader = null;
      }
      if (scalePort) {
        try {
          await scalePort.close();
        } catch (e) { }
        scalePort = null;
      }
      showScaleStatus('Scale disconnected. Please enter values manually.', 'info');
      const btn = document.getElementById('scaleBtn');
      if (btn) btn.textContent = 'Connect Scale';
    }

    function showScaleStatus(message, type) {
      const statusEl = document.getElementById('scaleStatus');
      if (!statusEl) return;

      statusEl.style.display = 'block';
      statusEl.textContent = message;

      // Set color based on type
      statusEl.style.background = type === 'success' ? '#d4edda' :
        type === 'warning' ? '#fff3cd' :
          '#d1ecf1';
      statusEl.style.color = type === 'success' ? '#155724' :
        type === 'warning' ? '#856404' :
          '#0c5460';
      statusEl.style.border = `1px solid ${type === 'success' ? '#c3e6cb' :
        type === 'warning' ? '#ffeaa7' :
          '#bee5eb'}`;
    }

    function handleCoilerFocus(cardNo, coilerNo) {
      // When a coiler input is focused, we're ready to receive scale data
      // The scale data will automatically populate when received
    }

    // Add button to connect/disconnect scale
    window.connectScale = async function () {
      const btn = document.getElementById('scaleBtn');
      if (scaleConnected) {
        await disconnectScale();
        if (btn) btn.textContent = 'Connect Scale';
      } else {
        if (btn) btn.textContent = 'Connecting...';
        await initScaleConnection();
        if (btn) btn.textContent = scaleConnected ? 'Disconnect Scale' : 'Connect Scale';
      }
    };
  </script>
  <script>
    // -----------------------------
    // RS232 SCALE INTEGRATION
    // -----------------------------
    let serialPort = null;
    let serialReader = null;
    let activeWeightInput = null;
    let keepReadingScale = false;

    function setActiveInput(input) {
      activeWeightInput = input;
    }

    // Add ENTER key navigation to weight inputs
    document.addEventListener('keydown', function (e) {
      if (e.key === 'Enter' && e.target.classList.contains('weight-val')) {
        e.preventDefault(); // Prevent form submission or default
        const allWeights = Array.from(document.querySelectorAll('.weight-val'));
        const currentIndex = allWeights.indexOf(e.target);
        if (currentIndex !== -1 && currentIndex < allWeights.length - 1) {
          const nextInput = allWeights[currentIndex + 1];
          nextInput.focus();
          setActiveInput(nextInput);
        }
      }
    });

    // Function to update Source based on manual entry vs scale
    function updateSource(input, type = 'Manual') {
      const row = input.closest('tr');
      const sourceCell = row.querySelector('.source-cell');
      if (sourceCell) sourceCell.textContent = type;
    }

    async function toggleScaleConnection() {
      const btn = document.getElementById('btnConnectScale');

      // If already connected, disconnect
      if (serialPort && serialPort.readable && keepReadingScale) {
        keepReadingScale = false;
        try {
          // Cancel the reader to break the loop
          if (serialReader) {
            await serialReader.cancel();
          }
          // The loop in readSerialLoop will release lock and we can close
          // But we need to wait a tiny bit or logic handles it
          // Actually, we just signal intention.
          // Correct implementation: reader.cancel() resolves read() with done=true.
          // Then loop exits. then releaseLock().

          btn.textContent = "Connect Scale (RS232)";
          btn.style.background = "#e67e22";
        } catch (e) {
          console.error("Disconnect error:", e);
        }
        return;
      }

      // Connect Logic
      if (!('serial' in navigator)) {
        alert("Web Serial API not supported in this browser. Please use Chrome or Edge.");
        return;
      }

      try {
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 9600 });

        btn.textContent = "Disconnect Scale";
        btn.style.background = "#c0392b"; // Red for disconnect action

        keepReadingScale = true;
        // Start reading loop
        readSerialLoop();
      } catch (err) {
        console.error('Serial Connection Error:', err);
        alert('Failed to connect to scale: ' + err.message);
      }
    }

    async function readSerialLoop() {
      while (serialPort.readable && keepReadingScale) {
        serialReader = serialPort.readable.getReader();
        try {
          while (true) {
            const { value, done } = await serialReader.read();
            if (done) {
              // Reader cancelled
              break;
            }
            // value is a Uint8Array. Decode it.
            const text = new TextDecoder().decode(value);
            handleSerialData(text);
          }
        } catch (err) {
          console.error(err);
        } finally {
          serialReader.releaseLock();
        }
      }
      // If we get here, port might be closable
      if (serialPort) {
        await serialPort.close();
        serialPort = null;
      }
    }

    let serialBuffer = "";
    function handleSerialData(chunk) {
      serialBuffer += chunk;

      // Common scale newlines: \r\n or \r
      if (serialBuffer.includes('\n') || serialBuffer.includes('\r')) {
        const lines = serialBuffer.split(/[\r\n]+/);
        serialBuffer = lines.pop(); // Keep incomplete chunk

        for (const line of lines) {
          if (!line.trim()) continue;

          // Regex to extract number (supports 12.34 g, + 12.34, etc)
          const match = line.match(/[-+]?[\d]*\.?[\d]+/);
          if (match) {
            const weight = parseFloat(match[0]);
            if (!isNaN(weight)) {
              applyScaleWeight(weight);
            }
          }
        }
      }
    }

    function applyScaleWeight(weight) {
      // Use active input, or find first empty weight input if none active
      let targetInput = activeWeightInput;

      if (!targetInput) {
        // Find first empty weight input
        const inputs = document.querySelectorAll('.weight-val');
        for (const input of inputs) {
          if (!input.value) {
            targetInput = input;
            break;
          }
        }
      }

      if (targetInput) {
        targetInput.value = weight;

        // Trigger calc (this triggers oninput="updateSource(this)" which sets Manual)
        const event = new Event('input', { bubbles: true });
        targetInput.dispatchEvent(event);

        // Overwrite Source to Scale AFTER the event
        updateSource(targetInput, 'Scale');

        // Flash effect
        targetInput.style.backgroundColor = "#d1fae5";
        setTimeout(() => targetInput.style.backgroundColor = "", 500);
      }
    }
  </script>
</body>

</html>